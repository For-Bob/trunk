https://design-patterns.readthedocs.io/zh_CN/latest/
创建型模式
	简单工厂模式：允许接口创建对象，但不会暴露对象的创建逻辑。
	工厂模式：允许接口创建对象，但使用哪个类来创建对象，则是交由子类决定的。
	抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类。
	建造者模式（Builder Pattern）：使用多个简单的对象一步一步构建成一个复杂的对象。
	原型模式(Prototype)：（其实就是用一个接口返回一个对象，这个对象是在已有的对象复制过来的，这样保留了之前对象的各种属性和数据）
			原型二字表明了改模式应该有一个样板实例，用户从这个样板对象中复制一个内部属性一致的对象，这个过程也就是我们称的“克隆”。被复制的实例就是我们所称的“原型”，这个原型是可定制的。
			意图：另外在软件系统中，有些对象的创建过程较为复杂，而且有时候需要频繁创建，原型模式通过给出一个原型对象来指明所要创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象，这就是原型模式的意图所在。

	单例模式：Singleton模式的要点在于一个类型只能被用来生成一个对象，且不能复制。所以，对于任何一个singleton方法的类型，必须要满足：(1) 构造，拷贝和析构函数都是private，
		所以，无法通过声明对象来构造，(2) 需要用静态成员变量来控制对象的个数，以保证不重复定义，(3) 需要有静态的“构造”函数和“析构”函数。
		
结构性模式：
	适配器模式：(adapter)适配器就是一种适配中间件，它存在于不匹配的二者之间，用于连接二者，将不匹配变得匹配，简单点理解就是平常所见的转接头，转换器之类的存在。
				意图：比如220v电压，110v电压分别转12v充电器
	装饰器模式：(decorator)允许向一个现有的对象添加新的功能，同时又不改变其结构。这种模式创建了一个装饰类，用来包装原有的类。
				意图：蛋糕，然后在水果蛋糕，蔬菜蛋糕，在蛋糕后面加上自己的属性，其实用的都是蛋糕
	代理模式：(proxy)提供一种可以对真实对象的访问对象，隐藏真实的对象，去除真实对象的非必要的职责。
			比如玩游戏，CF,LOL，腾讯代理，用户只需要腾讯的账号登陆就可以了，不然就需要访问CF在韩国的服务器，CF专有的账号，LOL的就需要访问LOL在美国的服务器，LOL专有的账号，代理模式就是省去了用户不需要去做自己不关系，额外的操作
	
	外观模式：　外观模式（Facade）,他隐藏了系统的复杂性，并向客户端提供了一个可以访问系统的接口。这种类型的设计模式属于结构性模式。为子系统中的一组接口提供了一个统一的访问接口，
					这个接口使得子系统更容易被访问或者使用。 
	桥接模式：桥接（Bridge）是用于把抽象化与实现化解耦，使得二者可以独立变化。这种类型的设计模式属于结构型模式，它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。
				  例子：总是喜欢用一个例子来讲解，那就是画图，这里有一个画笔，可以画正方形、长方形、圆形（这个大家都知道怎么做吧，我就不解释了）。但是现在我们需要给这些形状进行上色，这里有三种颜色：白色、灰色、黑色。
				  这里我们可以画出3*3=9中图形：白色正方形、白色长方形、白色圆形。。。。。。到这里了我们几乎到知道了这里存在两种解决方案：

				  方案一：为每种形状都提供各种颜色的版本。

				  方案二：根据实际需要对颜色和形状进行组合。
				  
				  对于有几个变化的维度，我们一般采用方案二来实现，这样除了减少系统中的类个数，也利于系统扩展。对于方案二的应用我们称之为桥接模式。
				  
				  操作系统和电脑之间是可以随机组合的，这就是一种解耦的方式，要比继承的方式优越了很多，意义更大更灵活。
	组合模式: (composite)将对象组合成属性结构以表示‘部分-整体’的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性.
				将对象组合成树形结构以表示“部分-整体”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。 树枝是list节点，树叶单个对象。
				
	享元模式：(flyWeight)在有大量对象时，有可能会造成内存溢出，我们把其中共同的部分抽象出来，如果有相同的业务请求，直接返回在内存中已有的对象，避免重新创建。
				举个最简单的例子，创建字符，比如ABC这种，组成英文单词的话就用享元模式了
				
行为型模式
	策略模式：策略模式（Strategy），定义了一组算法，将每个算法都封装起来，并且使它们之间可以互换。 							再比如我们去逛商场，商场现在正在搞活动，有打折的、有满减的、有返利的等等，其实不管商场如何进行促销，说到底都是一些算法，这些算法本身只是一种策略，并且这些算法是随时都可能互相替换的，比如针对同一件商品，今天打八折、明天满100减30，这些策略间是可以互换的。
	
	模板方法模式: 模版方法模式（template），就是定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模版方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。
					其实就是多态
	观察者模式： 观察者模式(observe)，定义对象间一种一对多的依赖关系，使得每当一个对象改变状态，则所有依赖它的对象都会得到通知并自动更新。
					其实就是将观察对象和通知对象分开，为了满足设计原则的低耦合

	命令模式：命令模式（order）可以将请求发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。
				就相当于遥控板控制电视一样，遥控板的按键需要解析为电视机能够接受的红外				
	
	状态模式：状态模式（status）允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(Objects for States)，状态模式是一种对象行为型模式。
				相当于请假，要一道一道审批，用户就只需提交，不管提到哪儿去，审批完这个然后继续提交，直到完全提交完成。
	
	中介者模式：中介者模式（Mediator）模式的定义：定义一个中介对象来封装一系列对象之间的交互，使原有对象之间的耦合松散，且可以独立地改变它们之间的交互。
				就是字面意思，来个中介，为买家和卖家，传递消息和服务
	
	责任链模式：顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。这种类型的设计模式属于行为型模式。
				在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。
	
	迭代器模式：其实就是STL的迭代器
	
	解释器模式：就是字面意思，用于解析字符例如：xml解析或者sql解析，解释器不通用，需要知道解析的符号，如果要增加字符就需要增加代码
	
	访问者模式：这个不太实用
	
	备忘录模式：备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。备忘录模式属于行为型模式。
				 1、后悔药。 2、打游戏时的存档。 3、Windows 里的 ctri + z。 4、浏览器中的后退。
				