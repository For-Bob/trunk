{动画 Animation
	{动画元素分类
		PropertyAnimation,可以改变各种类型property来产生动画效果。
		NumberAnimation,PropertyAnimation的派生类，专门改变数字类型的property来产生动画，效率相比PropertyAnimation更好。
		ColorAnimation，PropertyAnimation的派生类，专门改变color类型的property来产生动画，效率相比PropertyAnimation更好。
		RotationAnimation,PropertyAnimation的派生类，专门改变rotaion值，效率相比PropertyAnimation更好，另外还提供旋转方向等附加特性。
		Vector3dAnimation,PropertyAnimation的派生类，在一个Vector3d值发生变化时使用。
		PathAnimation，让对象沿一个给定的路径运动。
		SmoothedAnimation，允许一个property跟踪一个值，产生平滑动画。
		SpringAnimation,允许一个property跟踪一个值，动画效果类似于弹簧运动。
		Qt Quick还提供了用于组合多个动画对象的分组动画对象。
		SequentialAnimation,顺序执行一系列动画。
		ParallelAnimation,并行执行一系列动画。
		除了上面提到的动画对象，还有一些对象虽然本身不是直接的动画元素，但却是有些QML Item能够动起来的基础，称之为动画搭档。
			State，Item的状态，衔接Item的状态和动画，使状态变化过程平滑。
		还有一些动画元素，需要与其他动画对象结合才能产生较好的效果，称之为协同动画元素
			Behavior,为Item的property变化绑定一个默认的动画对象。
			ParentAnimation,在改变一个Item的parent时使用，是的该Item从旧parent移动到新parent的过程更平滑，通常与Transition、State、ParentChange联合使用。
			AnchorAnimation，在改变一个Item的parent时使用，平滑变化过程，通常与Transition、State、ParentChange联合使用。
			PauseAnimation，在动画过程中插入它，可以将动画过程暂停一段时间。
			PropertyAction，在动画执行过程中立即改变某个属性。
			ScriptAction,在动画执行过程中运行一段ECMAScript脚本。
	}
	
	{基本动画元素
		Animation是Qt Quick中所有动画类的基类，它具有下列属性：
			running,布尔值，指示动画是否在运行。默认是false。设置为true会启动动画，为false会停止动画。你可以读取它的值来判断动画当前是否在运行，也可以给它绑定一个表达式，
				当表达式的值为true时，动画会自动执行。start()方法会置其为true，stop()方法会置其为false。
			loops.动画的执行次数，默认值是1；给它赋值Animation.Infinite会导致动画循环执行永不停歇。
			paused,布尔值，指示动画是否被暂停，默认不暂停。调用pause()方法会置其为true，stop()方法会置其为false。
			alwaysRunToEnd,布尔值，默认值为false。它指示在显式的通知动画停止时是否把动画过程执行完。如果设置为true，那么即便你调用stop()或者设置running为false，动画都会自顾自地执行完。
		Animation有下列方法：
			start(),启动一个动画，如果一个动画已经在执行，它什么也不干。
			stop(),终止一个动画，如果动画没有执行完，那么动画操作的属性可能就是某个中间值，而不是目标值，当然要是你设置了alwaysRunToEnd,情况会有所不同，要是调用stop()时动画没有在运行，他什么也不干。
			restart(),等同于先调用stop()在调用start().
			pause(),暂停一个动画，如果动画已经暂停，他什么也不干。
			resume(),与pause()对应，让一个动画继续执行。如果一个动画没有被暂停或者不在运行状态，他什么也不干。
			complete(),完成一个动画。如果动画执行到某个中间步骤，这个调用会让动画直接跳到结束状态。动画要改变的property都会抵达目标状态。它会把running属性置为false。如果动画不在运行状态，什么也不干。
		Animation有下列信号：
			started(),动画开始时触发。注意，只有单独的顶层动画对象才会触发这个信号，如果一个动画对象处于某个动画分组中，在一个Behavior中或者在一个Transition中，都不会触发这个信号。
			stopped(),动画(手动或自动执行完毕)进入停止状态时触发。与started()信号一样，只有单独的顶层动画对象才会触发这个信号。
		了解了Animation对象，现在我们知道怎样启动一个动画了：
			调用start()方法。
			设置running为true。
			为running绑定一个表达式，表达式求值结果为true。
		我们也知道如何停止一个动画了：
			调用stop()方法。
			设置running为false。
			触发running绑定的表达式重新求值且返回值为false。
			调用complete()方法。
	}
	
	{PropertyAnimation是Animation的派生类，它通过改变对象的property来实现动画，基本上你能在Qt SDK中找到的Item property它都可改变，像NumberAnimation、ColorAnimation、RotationAnimation、Vector3dAnimation等都是它的子类。
		
		easing//容位
			easing.type : enumeration	//各种不同的路径
			{
				Easing.Linear
				Easing.InQuad
				Easing.OutQuad
				Easing.InOutQuad
				Easing.OutInQuad
				Easing.InCubic
				Easing.OutCubic
				Easing.InOutCubic
				Easing.OutInCubic
				Easing.InQuart
				Easing.OutQuart
				Easing.InOutQuart
				Easing.OutInQuart
				Easing.InQuint
				Easing.OutQuint
				Easing.InOutQuint
				Easing.OutInQuint
				Easing.InSine
				Easing.OutSine
				Easing.InOutSine
				Easing.OutInSine
				Easing.InExpo
				Easing.OutExpo
				Easing.InOutExpo
				Easing.OutInExpo
				Easing.InCirc
				Easing.OutCirc
				Easing.InOutCirc
				Easing.OutInCirc
				Easing.InElastic
				Easing.OutElastic
				Easing.InOutElastic
				Easing.OutInElastic
				Easing.InBack
				Easing.OutBack
				Easing.InOutBack
				Easing.OutInBack
				Easing.InBounce
				Easing.OutBounce
				Easing.InOutBounce
				Easing.OutInBounce
			}
			easing.amplitude : real
			easing.overshoot : real
			easing.period : real
		easing.bezierCurve : list<real>
		例子：BasePropertyAnimation.qml
				BasePropertyAnmaion1.qml
				BasePropertyAnimation2.qml
				BasePropertyAnimation3.qml
				BasePropertyAnimation4.qml
	
	}
	
	{NumberAnimation是PropertyAnimation的派生类，专门处理数字类型的property，它重写了from和to两个属性，将其类型设置为real。
		例子：BaseNumberAnimation.qml
	}
	
	{ColorAnimation是PropertyAnimation的派生类，专门处理color类型的property，它重写了from和to两个属性，将其类型设置为color。
		例子：BaseColorAnimation.qml
	}
	
	{RotationAnimation是PropertyAnimation的派生类，专门处理rotation和angle，它重写了from和to两个属性，将其类型设置为real。
		RotationAnimation新增了一个direction属性，可以取下列值：
			RotationAnimation.Numerical，默认值，在from和to两个角度之间做线性插值进行旋转，比如from=10,to=100，那就顺时针旋转90°。
			RotationAnimation.Colockwise,在两个角度之间顺时针旋转。
			RotationAnimation.Counterclockwise,在两个角度之间逆时针旋转。
			RotationAnimation.Shortest,选取两个角度之间的最短路径进行旋转，比如from=10，to=350，那结果将是逆时针旋转20°。
		使用RotationAnimation时不需要指定property属性。
		RotationAnimation在旋转一个Item时以Item的transformOrigin属性指定的点为中心，这个属性为枚举类型，默认值是Item.Center.它还是可以是Item.Top,Item.TopRight,
			Item.TopLeft,Item.BottomLeft,Item.BottomRight,Item.Bottom,Item.Left,Item.Right.\
		例子：BaseRotationAnimation;
	}
	
	{PathAnimation是从Animation继承而来的，它让目标对象沿着一个既定的路径运动。像PropertyAnimation一样，它也有一个easing属性，请参考PropertyAnimation的说明。
		anchorPoint属性描述目标对象的哪个点锚定在路径上，比如目标是一个正方形，你可以加设置中心点或左上角与路径锚定。默认是左上角。你可以使用"x，y"或者Qt.point()构造一个Point对象赋值给anchorPoint.
		orientation属性控制目标对象沿着路径运动时的旋转策略，它可以取下列值：
			PathAnimation.Fixed,orientation的默认值，在运动过程中保持物体方位不旋转。
			PathAnimation.RightFirst，旋转目标对象时努力使目标对象的右侧贴合路径。
			PathAnimation.LeftFirst，旋转目标对象时努力使目标对象的左侧贴合路径。
			PathAnimation.BottomFirst，旋转目标对象时努力使目标对象的底部贴合路径。
			PathAnimation.TopFirst，旋转目标对象时努力使目标对象的顶部贴合路径。
		如果你指定了orientation属性，一开始时目标对象的方向和设定值不符合，PathAnimation就会旋转目标对象以便指定的边贴合路径，而orientationEntryDuration属性用于设定完成这个旋转的时间周期。
		如果你指定了orientation属性，而目标对象在到达路径末端时的旋转角度和你期望的不符，则可以设置endRotation属性类指定一个角度，那么当目标对象抵达路径末端时会自动调整旋转角度为
			指定的endRotation。此时如果你设置了orientationExitDuration属性，旋转过程就会以动画的形式完成，否则就会发生一个跳变。
		最后要说patn属性了，类型就是Path，这就是你要构造的路径。
		
		例子：BasePathAnimation.qml
			
	}
	
	{SmoothedAnimation
		SmoothedAnimation是NumberAnimation的派生类，它默认将easing.type设置为Easing.InOutQuad,在from和to之间产生平滑的动画效果。
		duration属性设置动画周期，单位是毫秒。默认值是-1，禁用duration模式。
		velocity设置速率，默认速率是200units/秒。将velocity设置为-1禁用速率。如果from和to的距离很短，SmoothedAnimation会自行调整velocity来适应。
		当duration和velocity同时设置时，SmoothedAnimation会根据from、to之间的距离和速率计算出按照速率完成动画所需的时间，拿这个时间与duration比较，如果duration短就使用duration，否则使用velocity。
		例子：BaseSmoothed.qml.qml
	}
	
	{SpringAnimation
		SpringAnimation模仿弹簧的震荡行为。
		spring属性用来控制动画的加速度，0~5.0之间的取值时有意义的，默认值为0.
		damping属性代表衰减系数，其值越大振荡就会越快平复，0~1.0之间的值比较有意义，默认值为0.
		epsilon允许你设定一个最接近0的阈值来代表0，如果是基于像素位置的动画，0.25是一个比较合适的值；如果是基于scale的动画，那可以0.005比较合适。默认值是0.001.调整epsilon可能会带来一定的性能提升。
		velocity属性设定动画的最大速率，默认值为0.
		例子：BaseSpringAnimation.qml
	}
	
	{组合动画
		ParallelAnimation和SequentialAnimation允许我们把多个动画元素组合在一起来执行。ParallelAnimation中定义的多个动画对象会并行执行，而SequentialAnimation中定义的多个动画对象会一个个顺序执行。
		{ParallelAnimation
			ParallelAnimation从Animation继承而来，没有添加额外的属性，它本身单独使用没有意义，不产生动画效果。你只需要在声明ParallelAnimation对象时在其中定义多个子动画对象，ParallelAnimation开始运行时就会并行执行它们。
			例子：BaseParalelAnimation.qml
		}
		{SequentialAnimation
			SequentialAnimation与ParallelAnimation类似，不同之处是它的子动画对象时一个个顺次执行的。动画对象的定义方法和PropertyAnimation元素类似。
			例子：BaseSequentialAnimation.qml
		}
	}
	
	{State
		很多用户界面由状态驱动，根据应用场景，针对特定的状态显示不同的界面。
		在QML中，状态时定义在State类型中的一系列属性配置。不同的配置可能有不同的作用：
			显示一些UI组件，隐藏另一些。
			想用户呈现不同的操作和功能。
			启动，暂停，停止动画。
			在某种新的状态下执行某些脚本。
			改变某个特定Item的property的值。
			显示一个不同的view或screen。
		例子：BaseState.qml
		Item有一个state属性，时字符串类型，它保存Item的当前状态的名字，如果你没有设置过Item的状态，它默认就是空串。你可以打印它的值来查看Item的当前状态。你可以设置state的值来改变Item的状态，如果给它一个空串，Item就会返回默认状态。
		Item还有一个states属性，保存为这个Item定义的所有状态，它的类型是list<State>.可以看到，它是一个列表，列表中的每个State对象代表一种状态。
		State类型对应的C++类型是QQuickState，它有这么几个属性：
			name，字符串，保存状态的名字。你为某个Item定义的每种状态的名字，在Item范围内都应该是唯一的。
			when，布尔值，它描述状态在什么时候应用。它应该被绑定到一个ECMAScript表达式上，当这个表达式返回结果为true是应用本状态。
			extend，字符串，指向当前状态的“基态”的名字，所谓“基态”，类比C++中的基类概念。基态的所有变化都会被派生态继承。
			changes，类型是list<Change>,一个列表，保存应用于这种状态的所有变化。这是State的默认属性。Change对应于C++类QQuickStateOperation。
		State的changes属性保存Change对象的列表，当进入一种状态后，这个列表中的Change对象会顺次执行。Qt Quick提供了多种Change对象
		总结一下，应用一种状态有两种方式：
			显式改变Item的state属性。
			将State的when属性绑定到一个表达式上。
		State对象必须与它的拍档Change对象一起使用才有实际意义。提供了下面几种可用于State的Change对象：
			PropertyChanges，用来改变一个对象的属性，对应的C++类为QQuickPropertyChanges，是QQuickStateOperation的派生类。
			ParentChange,用来改变一个对象的富，对应的C++类为QQuickPrentChange，是QQuickStateOperation的派生类。
			AnchorChanges，用来改变一个对象的锚布局参数，对应的C++类为QQuickAnchorChanges，是QQuickStateOperation的派生类。
			StateChangeScript，用来执行一个ECMAScript脚本，对应的C++类为QQuickStateChangeScript，是QQuickStateOperation的派生类。
		PropertyChanges对象来改变文本的颜色和字体。其中对应鼠标按下的State对象时这么定义的：
			State{
				name：“blueText”
				when：mouseArea.pressed;
				PropertyChanges{
					target:centerText;color:"blue";
					font.bold:true; font.pixelSize:32;}
				}
			这个名为“blueText”的对象内声明了一个PropertyChanges对象，用来改变centerText的某些属性。
			PropertyChanges对象有一个target属性，指向要改变的目标对象，在我们的示例中，指向id示centerText的Text对象，其余的代码就是改变centerText的color，font属性，与声明Text对象时的用法一样。target属性的初始化语句和修改目标对象的语句之间没有必然的先后关系。
			PropertyChanges的restoreEntryValues属性也是个布尔值，用于指定离开本状态时是否将本状态改变的那些属性的值重置为进入本状态之间的值。默认值ture，假如设置这个属性为false，name这种状态对目标对象的改变将是持久的。
			PropertyChanges设定目标对象的属性是，可以使用静态的值，也可以使用表达式。如果使用表达式，则默认会将表达式和属性绑定。explicit可以修改这种行为，它的默认值是false，如果你把他置为true，那么任何可能的表达式绑定都将被视作一次性的赋值行为。
			例子：BaseStateRect.qml
		ParentChange
			ParentChange用来改变一个对象的parent。它具有下列属性：
			target，指定要操作的目标对象。
			parent，指定目标对象的新parent。
			x，指定目标对象相对于新parent的x位置
			y，指定目标对象相对于新parent的y位置
			width，指定目标对象的宽度
			height，指定目标对象的高度。
			roration，指定目标对象的旋转角度。
			scale，指定目标对象的放大系数。
			上面这些属性，除了target和parent的类型是Item，其他的都是real。
			
			需要注意的时，对于ParentChange对象，你只能使用它定义的那几个属性，否则会报错。
			例子：BaseParentChange.qml
		AnchorChanges
			AnchorChanges用来改变一个Item的锚布局属性，。它支持下列属性：
			target，指向目标对象。
				anchors.left
				anchors..right
				anchors.top
				anchors.bottom
				anchors.horizontalCenter
				anchors.verticalCenter
				anchors.baseline
			AnchorChanges不能改变一个Item的锚布局留白，不过你可以使用PropertyChanges改变它们。
			例子：BaseAnchorsChanges.qml
		StateChangeScript
			StateChangeScript允许你在状态变化时执行ECMAScript脚本。它有两个属性，一个是name，表示脚本的名字，这个名字可以被ScriptAction对象引用，以便复用这里的脚本代码：一个是script，代表这里的脚本代码。
			例子：BaseStateChangeScript.qml
		}
	}
	
	{Transition
		假如你要从A地去往B地，Transition会给你选择，做动车，绿皮火车，绿皮火车，大巴，自驾还是飞机。
		简而言之，过渡将动画引入到两种状态之间，消除状态突变。
		当一个Item从一个State切换到另一个State时，Transiton定义的动画会自动在两个State之间运行，从来消除状态间的突变，使得迁移更加平滑。
		Item的transitions属性是个列表，保存为这个Item定义的所有Transition。你可以为Item定义一个或多个Transiton。只需这样:
		Item{
			...
			transitions:Transition{
				NumberAnimation{properties:"x,y"; duration: 2000}
			}
			...
		}
		或者这样
		Item{
		...
			transitions:[
				Transition{
					from: "stateA"
					to: "stateB";
					NumberAnimation{properties:"x,y"; duration: 2000}
				},
				Transition{
					from: "stateB"
					to: "stateA";
					NumberAnimation{properties:"x,y"; duration: 2000}
				},
			]
			...
		}
		Transition的enabled属性设置一个Transition是否使能，默认值为true。
		Transition的from属性用来指定触发过渡的状态(的名字)，其默认值为"*"，匹配所有状态，to属性指定过渡的目标状态(的名字)，默认值也是"*"。如果你不设置from和to属性，那么Transition就会匹配所有的状态变化，不管Item的状态从哪个变到哪个，只要Transition的enabled为true，Transition就会执行。
			你可以通过设定from和to来控制一个Transition的触发条件，达到这样的效果：只要Item从状态"A"迁移到状态"B"时才执行Transition，通过这样的设定你就可以为Item定义多个Transition，每个Transition匹配不同的状态迁移路径。
		如果你想知道一个Transition是否在运行，可以读取它的只读属性running，true代表Transition正在运行。
		animations列表属性保存为一个Transition定义的所有Animation。你可以在Transition内使用基本的Animation对象，也是使用SequentialAnimation、ParallelAnimation等分组Animation对象。在介绍PropertyAnimation时讲了Animation的三种定义与使用方式，在Transition中使用就是第四种方式。
		reversible属性指定触发transition的条件反转时Transition是否自动反转，默认值false。如果你没有将指定Transition的from和to属性，那么多个transition是并发执行的，而且会应用到所有状态变化路径上；此时不需要设置reversible属性，因为当Item的State反转时也会触发transition。但是如果你使用了SequentialAnimation或者设置了from、to属性，
			那么在某些场景下你可能需要设置reversible属性才能达到预期的效果。比如你为一个按钮定义了一个Transition(先放大后变色)来响应鼠标左键按下这个动作，当鼠标左键释放时需要恢复按钮的状态，此时你可能想先变色在缩小，那你就要设置reversible属性。
		当你为一个Transition定义动画时，不需要为Animation指定from和to属性。from属性默认值会被设置为Item对应属性的当前值，而to属性则会被设置为目标状态内为该属性设定的目标值。当然，要是你愿意的话，也可以手动设置它们来覆盖默认值。target属性也不用指定，结合State和Transition，target时显而易见的。
		例子：BaseTransition.qml BaseLinkText.qml
		
	}
	{协同动画元素
		处理基本的动画元素和分组动画元素，还有一些需要和其他的动画辅助类(如Behavior、Transition)或者动画类结合使用才用更有实际意义的动画元素，我把他们叫作协同动画元素，都安排到这部分来介绍。
		Behavior对象应用于给Item的某个属性绑定默认动画。
		ParentAnimation，AnchorAnimation通常需要和Transition、State联合使用。
		PauseAnimation，可以插入在多个动画之间产生暂停效果。
		PropertyAction可以插入在多个动画之间来立即改变某个属性。
		ScriptAction用于在动画执行过程中运行一段ECMAScript脚本。
		
		Behavior
			Behavior用来给一个property定义默认动画，当该property变化是执行该动画。一个property只能绑定一个Behavior，一个Behavior内只能有一个顶层动画(因为其animation属性的类型是Animation，而非list<Animation>)，如果你想在一个property变化是执行多个动画，则可以使用ParallelAnimation或SequentialAnimation。
			如果你给Item定义了State，而State变化时触发了Transition，Transition要改变的property上绑定了Behavior，那么Transition会覆盖Behavior。
			例子：BaseBehaviorAnimation.qml
		ParentAnimation
			ParentAnimation在改变一个Item的parent时使用，使得该Item从旧parent移动到新parent的过程更平滑。他是Animation的派生类，其newParent属性用来指定目标对象的新parent：target属性指定目标对象；via属性指定动画过程中参考的其他对象。比如要改变parent的Item，其旧父，新父都可能被别的Item遮住，此时移动过程可能是不可见，而给via设置一个Z序最大，处于顶层的Item，就可以确保动画过程可见。
			ParentAnimation可以包含一个或多个其他的动画对象，这些动画会并发执行。如果不包含其他动画，ParentAnimation体现不出来任何效果
			例子：BaseReparentRectAnimation.qml
		AnchorAnimation
			AnchorAnimation只能与Transition、AnchorChanges联合使用，不能在Behavior或其他的动画元素中使用。
			你可以设定duration。easing及targets属性。不过与Transition结合使用，一般不必设置targets属性。
	}
}