
{QWdiget，QDialog和QMainWindow的区别		
	QWidget类是所有用户界面对象的基类，QMainWindow和QDialog都是QWidget的子类。窗口部件是用户界面的一个基本单元：它从窗口系统接收鼠标、键盘和其它事件，并且在屏幕上绘制自己。每一个窗口部件都是矩形的，并且它们按Z轴顺序排列。一个窗口部件可以被它的父窗口部件或者它前面的窗口部件盖住一部分。 

    QMainWindow 类提供一个有菜单条、锚接窗口（例如工具条）和一个状态条的主应用程序窗口。主窗口通常用在提供一个大的中央窗口部件（例如文本编辑或者绘制画布）以及周围 菜单、工具条和一个状态条。QMainWindow常常被继承，因为这使得封装中央部件、菜单和工具条以及窗口状态条变得更容易，当用户点击菜单项或者工具条按钮时，槽会被调用。

    QDialog类是对话框窗口的基类。对话框窗口是主要用于短期任务以及和用户进行简要通讯的顶级窗口。QDialog可以是模态对话框也可以是非模态对话框。QDialog支持扩展性并且可以提供返回值。它们可以有默认按钮。QDialog也可以有一个QSizeGrip在它的右下角，使用setSizeGripEnabled()。 

    QDialog 是最普通的顶级窗口。一个不会被嵌入到父窗口部件的窗口部件叫做顶级窗口部件。通常情况下，顶级窗口部件是有框架和标题栏的窗口（尽管使用了一定的窗口部件标记，创建顶级窗口部件时也可能没有这些装饰。）在Qt中，QMainWindow和不同的QDialog的子类是最普通的顶级窗口。

    如果是顶级对话框，那就基于QDialog创建，如果是主窗体，那就基于QMainWindow，如果不确定，或者有可能作为顶级窗体，或有可能嵌入到其他窗体中，则基于QWidget创建。
}
	
	{QWdiget::setWindowFlags:设置右上角的最小化，最大化，关闭按钮的，QWdiget，QDialog，QMainWindow都可以用
		具体属性说明：WindowFlags.json
	}
	
	QCoreApplication::applicationDirPath(); //返回程序的执行文件路径
	
	{QWdiget::setAttribute(Qt::WidgetAttribute attribute, bool on = true)
		如果on=true,设置widget的属性，on=false清除这些属性
		Qt::WidgetAttribute
			Qt::WA_AcceptDrops			
	}
	
	{QSS设置控件样式
		QWdiget::setStyleSheet()
			具体样式说明：qss.json
	}
	
	{QGraphicsView 
		QT4.2开始引入了Graphics View框架用来取代QT3中的Canvas模块，并作出了改进框架实现了模型－视图结构的图形管理，能对大量图元进行管理，支持碰撞检测，坐标变换和图元组等多种方便的功能。
		GraphicsView框架结构主要包含三个主要的类QGraphicsScene（场景）、QGraphicsView（视图）、QGraphicsItem（图元）。
		GraphicsView是一个基于图元的Model/View架构的框架，每一个组件都是一个独立的元素。QPainter采用面向过程的描述方式绘图；GraphicsView采用面向对象的描述方式绘图。
		GraphicsView绘图时首先创建一个场景，然后创建图元对象，再使用场景的add()函数，将图元对象添加到场景中，最后通过视图进行显示。
		比如：
			QGraphicsScene scene;
			scene.addText("Hello, world!");

			QGraphicsView view(&scene);
			view.show();
	}
	
	{QTcpSocket
		QTcpServer的基本操作：
		一、
			1. 创建一个QTcpServer
			2. listen(ip,port)	
			3. 连接信号newConnection，在槽函数里调用nextPendingConnection获取连接进来的socket。
				socket->write(msg.toUtf8());// write qstring msg
				socket->flush();//send right now
				socket->waitForReadyRead()
				socket->readAll();
				socket.disconnectFromHost();
				socket.waitForDisconnected();
				socket.close();
		二、
			1. 创建一个QTcpServer
			2. listen(ip,port)	
			3. 重写incomingConnection(qintptr handle)这个函数，在这个里面处理
				创建socket
				socket->setSocketDescriptor(handle)
				socket->write(msg.toUtf8());// write qstring msg
				socket->flush();//send right now
				socket->waitForReadyRead()
				socket->readAll();
				socket.disconnectFromHost();
				socket.waitForDisconnected();
				socket.close();
		QTcpClient的基本操作：
			1. 创建一个QTcpSocket
			2. 连接信号readyRead槽函数，异步读取数据
			3. 连接信号connected，判断是否连接成功
			4. 调用waitForReadyRead，阻塞读取数据			
			5. 调用connectToHost(ip,port)连接服务器
			6.waitForReadyRead();//-----------------这个一定要放到最后，不然主线程要阻塞			
	}
	
	{QUdpSocket
		server:
			1.创建一个QUdpSocket
			2.m_pUdpSocket->writeDatagram(msg.toStdString().c_str(), QHostAddress::Broadcast, 45454);//1.msg,2.绑定方式，3.端口
		client：
			1.创建一个QUdpSocket
			2.m_pUdpSocket->bind(45454, QUdpSocket::ShareAddress);//1.端口，2.绑定方式
			3.connect(m_pUdpSocket, &QUdpSocket::readyRead, this, &udpClient::reviceData);//连接信号与槽
			4.m_pUdpSocket->waitForReadyRead();//等待可读
			5.void udpClient::reviceData() //槽函数
			{
				qDebug() << "data is coming";
				while (m_pUdpSocket->hasPendingDatagrams()) 
				{
					QByteArray data;
					data.resize(m_pUdpSocket->pendingDatagramSize());
					m_pUdpSocket->readDatagram(data.data(), data.size());
					qDebug() << "------------:" << data;
					m_pUdpSocket->close();									//---------下面一定要这样写，否则就只会接受一次
					m_pUdpSocket->bind(45454, QUdpSocket::ShareAddress);
					m_pUdpSocket->waitForReadyRead();
				}
			}
	}
	
	{QThreadPool //qt线程池
		 static QThreadPool *QThreadPool::globalInstance()；
			返回QThreadPool的对象
		 void QThreadPool::start(QRunnable *runnable, int priority = 0)
			启动，如果当前线程大于maxThreadCount(),就会放在队列里面等待。
		
		1.继承QRunnable,
		2.把需要的方法重写run接口里面
		3.QThreadPool::globalInstance()->start(object);//start这个对象，然后就会在run里面运行
			
		例子：
			class HelloWorldTask : public QRunnable
			{
			  void run()
			  {
				  qDebug() << "Hello world from thread" << QThread::currentThread();
			  }
			};

			HelloWorldTask *hello = new HelloWorldTask();
			// QThreadPool takes ownership and deletes 'hello' automatically
			QThreadPool::globalInstance()->start(hello);
	}
	
	{QDialog //对话框
		{QColorDialog:		//颜色对话框，会弹出一个颜色选择的对话框
			1.静态方法
				QColor color = QColorDialog::getColor(Qt::red, this, tr("color pick"));//默认颜色是红色；父对象（qobject内存管理机制）；标题
			2.QColorDialog dialog(Qt::red, this);//默认红色，父对象
				dialog.setOption(QColorDialog::ShowAlphaChannel);//现实alpha选项
				dialog.exec();//模态显示
				QColor color = dialog.currentColor();//获取显示
		}
		
		{QFileDialog：		//文件对话框，会弹出文件选择的对话框
			选择单个文件
				QString file = QFileDialog::getOpenFileName(this, tr("file"), "D:", tr("pic file(*png *jpg)"));//父对象； 对话框标题； 打开的位置(位置可以变化的)；文件格式
				QString file = QFileDialog::getOpenFileName(this, tr("file"), "D:", tr("pic file(*png *jpg);;txt file(*txt)"));第四个参数，两种文件格式，用两个分号隔离
			选择多个文件(要shift多个选择)
				QStringList file = QFileDialog::getOpenFileNames(this, tr("file"), "D:", tr("pic file(*png *jpg)"));
		}
		
		{QFontDialog		//字体选择对话框，
			bool ok;
			QFont font = QFontDialog::getFont(&ok, this);//bool值用于确定，点击的确定还是取消； 父对象
			if(ok)
				qDebug() << " select font: " << font;
			else
				qDebug() << "no select any font" ;
			
		}
		
		{QInputDialog		//输入对话框
				//获取字符串
			    QString str = QInputDialog::getText(this, tr("输入字符黄对话框"), tr("输入用户名字"), QLineEdit::Normal, tr("admin"), &ok);
				//参数说明：父对象; 对话框标题; 输入框上面标题; 显示模式; 按钮信息
				
				//获取整数
				int value = QInputDialog::getInt(this, tr("输入整数对话框"), tr("输入-1000到1000之间的整数"),100, -1000, 1000, 10, &ok);
				//参数说明：父对象; 对话框标题; 输入框上面标题; 默认参数，最小值，最大值，步进值(旁边有步进按钮)，按钮信息
				
				//获取浮点数，只能有一位小数点，这个应该不标准的
				double str = QInputDialog::getDouble(this, tr("输入浮点数对话框"), tr("输入-1000到1000之间的数值"),0.12, -1000, 1000, 1, &ok);
				//参数说明：父对象; 对话框标题; 输入框上面标题; 默认参数，最小值，最大值，步进值(旁边有步进按钮)，按钮信息
				
				//获取条目
				QStringList items;
				items << tr("条目1") << tr("条目2");
				QString str = QInputDialog::getItem(this, tr("输入条目对话框"), tr("请选择或输入一个条目"), items, 0, true, &ok);
				//参数说明：父对象，对话框标题; 输入框上面标题;条目内容，默认显示第几个条目，true可编辑/false不可编译，按钮信息
		}
		
		{QMessageBox		//消息对话框
				int ret = QMessageBox::question(this, tr("问题对话框"), tr("你了解QT吗？"), QMessageBox::Yes, QMessageBox::No);//问题对话框

				ret = QMessageBox::information(this, tr("提示对话框"), tr("这个Qt书籍！"), QMessageBox::Ok);//提示对话框

				ret = QMessageBox::warning(this, tr("警告对话框"), tr("不能提前结束"), QMessageBox::Abort);//警告对话框

				ret = QMessageBox::critical(this, tr("严重错误对话框"),tr("发现一个严重错误！现在要关闭所有文件！"),QMessageBox::YesAll);//错误对话框

				QMessageBox::about(this, tr("关于对话框"), tr("普及Qt Creator的普及工作"));//关于对话框
		}
		
		{QprogressDialog	//进度对话框
			QProgressDialog dialog(tr("文件复制进度"), tr("取消"),0,50000, this);
										//进度条上面的内容，取消按钮内容，最小值，最大值，指针
			dialog.setWindowTitle(tr("进度对话框"));//对话框标题
			dialog.setWindowModality(Qt::WindowModal);//对话框为模态，取消这句设置为非模态
			dialog.show();//显示
			for(int i = 0; i < 50000; ++i)
			{
				QThread::msleep(1);
				dialog.setValue(i);//设置当前进度
				QCoreApplication::processEvents();//避免界面冻结
				if(dialog.wasCanceled())//取消按钮，按下的处理
					break;
			}
			dialog.setValue(50000);//for只能到49999，这里是为了完美处理
			
		}
		
		{QErrorMessage		//错误对话框
			QErrorMessage* message = new QErrorMessage(this);
			message->setWindowTitle(tr("错误信息对话框"));		//标题
			message->showMessage(tr("这里是出错信息！"));		//对话框内容
		}
		
		{QWizard //向导对话框：就像QT的安装向导一样，下一步下一步这样点击
			QWizard wizard(this);
			wizard.setWindowTitle(tr("向导对话框"));
			wizard.addPage(this->CreatePageOne());
			wizard.addPage(this->CreatePageTwo());
			wizard.addPage(this->CreatePageThree());
			wizard.exec();
			
				QWizardPage* MainWindow::CreatePageOne()
				{
					QWizardPage* page = new QWizardPage;
					page->setTitle(tr("介绍"));
					return page;
				}

				QWizardPage* MainWindow::CreatePageTwo()
				{
					QWizardPage* page = new QWizardPage;
					page->setTitle(tr("用户选择信息"));
					return page;
				}

				QWizardPage* MainWindow::CreatePageThree()
				{
					QWizardPage* page = new QWizardPage;
					page->setTitle(tr("结束"));
					return page;
				}			
		}
		
	}
	
	{QFrame类:QFrame类是带有边框的部件的基类。
		它的常用的子类有QLable,QLCDNumber，QSplitter，QStackedWidget,QToolBox和QAbstractScrollArea
		
		QFrame类边框形状的取值
		常量							描述
		QFrame::NoFrame					QFrame不进行绘制
		QFrame::Box						QFrame在它的内容四周绘制一个边框
		QFrame::Panel					QFrame绘制一个面板，使得内容表现为凸起来或者凹陷
		QFrame::StyledPanel				QFrame绘制一个矩形面板，它的效果依赖于当前的GUI样式，可以凸起来或者凹陷
		QFrame::HLine					QFrame绘制一条水平线，没有任何框架
		QFrame::VLine					QFrame绘制一条垂直线，没有任何框架
		QFrame::WinPanel				QFrame绘制一个类似于Windows2000中的矩形面板，可以凸起来或者凹陷
		
		QFrame类边框阴影的取值
		常量							描述
		QFrame::Plain					边框和内容没有3D内容，与四周界面在同一水平面上
		QFrame::Raised					边框和内容表现为凸起，具有3D效果
		QFrame::Sunken					边框和内容表现为凹陷，具有3D效果
		
		 QFrame* frame = new QFrame(this);
		frame->setFrameShape(QFrame::Box);
		frame->setFrameShadow(QFrame::Sunken);
		frame->setLineWidth(2);					//边框宽度
		frame->setMidLineWidth(10);				//中间的线
		frame->move(50, 50);
		
		{子类介绍
		{QLable显示图片和文字，
		}
		
		{QStackedWidget 提供了一个部件栈，可以有多个界面，每个界面可以有自己的部件，不过每次只能显示一个界面
		}
		
		{QToolBox提供了一列叠窗口部件，就像QQ中的抽屉效果。
		}
		
		{QAbstractButton类是按钮部件的抽象基类，提供了按钮的通用功能。
			它的子类包括QCheckBox，标准按钮QPushButton，单选框按钮QRadioButton(用QGroupBox来管理radioButton)和工具按钮QToolButton。
		}
		
		{QLineEdit单行的文本编辑器
			显示模式(echoMode):
				Normal					正常显示输入的信息
				NoEcho					不显示任何输入
				Password				显示为密码样式
				PasswordEchoOnEdit		编辑时正常显示，其他情况显示下为密码样式。
			
			输入掩码
				inputMask来限制输入的内容，
				字符(必须输入)		字符(可留空)			含义
				A					a						只能输入A~Z,a~z
				N					n						只能输入A~Z,a~z,0-9
				X					x						可以输入任意字符
				9					0						只能输入0-9
				D					d						只能输入1-9
									#						只能输入加号(+),减号(-),0-9
				H					h						只能输入十六进制字符，A-F,a-f,0-9
				B					b						只能输入二进制字符,0或者1.
						>									后面的字母字符自动转换为大写
						<									后面的字母字符自动转换为小写
						!									停止字母字符的大小写转换
						\									讲该表中的特殊字符正常显示用作分隔符
			输入验证
				validator来输入进行约束。
				QValidator* validator = new QIntValidator(100, 999,this);//指定范围为100-999
				lineEdit->setValidator(validator);//在行编辑器中使用验证器
				正则表达式
					QRegExp rx("-?\\d{1.3}");//开始输入"-"或者不输入，然后输入1~3个数字的限制
					QValidator* validator = new QRexgExpValidator(rx, this);
			自动补全
				利用QCompleter类实现
				QStringList wordList;
				wordList << "Qt" << "Qt Creator" << tr("你好");
				QCompleter * completer = new QCompleter(wordList, this);//新建自动完成器
				completer->setCaseSensitivity(Qt::CaseInsensitive);		//设置大小写不敏感
				lineEdit->setCompleter(completer);	//输入Q，就会出现Qt, Qt Creator
		}
		}
	}
	
	{QAbstractSpinBox是一个抽象基类，提供了一个数值设定框和一个行编辑器
		它有3个子类
			QDateTimeEdit:完成日期时间设定
			QSpinBox：整数设定，数值加减。
			QDoubleSpinBox：浮点数的设定。		
	}
	
	{QAbstracSlider提供区间内的一个整数值，它有一个滑块，可以定位到一个整数区间的任意指。
		QScrollBar多数是用在QScrollArea类中来实现滚动区域;
		QSlider就是常见的音量控制或多媒体播放进度等滑块部件;
		QDial是一个刻度表盘部件。
	}
	
	{QLayout是布局管理器的基类，是一个抽象基类
		QLayout和QLayoutItem都是在设计自己的布局管理器时才使用的
		QBoxLayout 基本布局管理器
		QGridLayout 栅格布局管理器
		QFormLayout 窗体布局管理器
		QStackedLayout 栈布局管理器
		
		布局管理器常用属性说明
			属性						说明
			layoutName					现在所使用的布局管理器的名称
			layoutLeftMargin			设置布局管理器到界面左边界的距离
			layoutTopMargin				设置布局管理器到界面上边界的距离
			layoutRightMargin			设置布局管理器到界面右边界的距离
			layoutBottomMargin			设置布局管理器到界面低边界的距离
			layoutSpacing				布局管理器中各个子部件间的距离
			layoutStretch				伸缩因子
			layoutSizeConstraint		设置大小约束条件
		
		设置layout是否可变
			常量								描述
			QSizePolicy::Fixed					只能使用sizeHint()提供的值，无法伸缩
			QSizePolicy::Minimum				sizeHint()提供的大小是最小的，部件可以被拉伸
			QSizePolicy::Maximum				sizeHint()提供的是最大大小，部件可以被压缩	
			QSizePolicy::Preferred				sizeHint()提供的大小是最佳代销，部件可以被拉伸或者压缩
			QSizePolicy::Expanding				sizeHint()提供的是合适的大小，部件可以被压缩，不过它更倾向于被拉伸来获得更多的空间
			QSizePolicy::MinimumExpanding		sizeHint()提供的大小是最小的，部件倾向于被拉伸来获取更多的空间
			QSizePolicy::Ignored				sizeHint()的值被忽略，部件将尽可能的被拉伸来获取更多的空间
	}
	
	{QMainWindow主窗口框架
		拥有以下组件
		菜单栏(QMenuBar): 菜单栏包含了一个下拉菜单项的列表，这些菜单项由QAction动作类实现。菜单栏位于主窗口的顶部，一个主窗口只能有一个菜单栏。
			添加控件QMenu
		工具栏(QToolBar): 工具栏一般用于显示一些常用的菜单项目，也可以插入其他窗口部件，并且是可以移动的。一个主窗口可以拥有多个工具栏。
		中心部件(Central Widget): 在主窗口的中心区域可以放入一个窗口部件座位中心部件，是应用程序的主要功能实现区域。一个主窗口只能拥有一个中心部件。
		Dock部件(QDockWiget): Dock部件常被称为停靠窗口，因为可以停靠在中间部件的四周，因为可以挺高在中间部件的四周，用来防止一些部件来实现一些功能，像一个工具箱一样。
		状态栏(QStatusBar): 状态栏用于显示程序的一些状态信息，在主窗口的最底部。一个主窗口只能拥有一个状态栏。
	}
	
	{富文本处理：简单来说就是在文档中可以使用多种格式，比如字体颜色、图片和表格等。
		文档的光标主要基于QTextCursor类，文档的框架主要是基于QTextDocument类。
		富文本文档的结构分为几种元素来表示：
			框架(QtextFrame)、文本块(QTextBlock)、表格(QTextTable)和列表(QTextList)。
			每种元素的格式又使用相应的format类来表示，分别是框架格式(QTextFrameFormat)、文本块格式(QTextBlockFormat)、表格格式(QTextTableFormat)和列表格式(QTextListFormat)一般在编辑文档时使用。
	}
		
	{事件
		事件与信号是两个不同层面的东西，鼠标按钮产生鼠标事件，按钮被按下，发射clicked()单击信号。
		
		事件传递是先焦点部件，然后再是父部件。如果焦点部件安装了事件过滤器，就会是先事件过滤器，然后焦点部件，最后再是父部件。		
			installEventFilter()//安装事件过滤器
			eventFilter()		//处理过滤的事件， return true，就不会向下传递了，return false继续下一级处理。
		
		QCursor 		//光标
		
		QDragEnterEvent //拖动进入事件
		
		QDropEvent		//放下事件
		
		QMouseEvent		//鼠标事件
		
		QWheelEvent		//滚轮事件
		
		QKeyEvent		//键盘事件
		
		QTimerEvent		//定时器事件		随机数： qrand()和qsrand()实现的
		
		发送事件
			sendEvent	会立即处理给定的事件，在事件发送完成后无法自动删除
			postEvent	放在等待调度队列中，在事件发送后自动删除
	}
	
	{对象模型与容器类
		{对象模型：
			信号和槽：
				用于两个对象之间的通信.回调就是函数指针，回调有缺陷，1.不是类型安全，不能保证回调时使用正确的参数；2.强耦合，处理焊丝必须知道调用哪个回调函数。
				第5个类型
				Qt::AutoConnection				自动连接，如果槽在同一个线程就是直接连接，如果槽不在同一个线程就是队列连接。
				Qt::DirectConnection			直接连接，槽和信号在同一个线程执行。
				Qt::QueuedConnection			队列连接，接受者所在线程会从队列里面循环去取。
				Qt::BlockingQueuedConnection	阻塞连接，信号会阻塞，直到槽返回
				Qt::UniqueConnection			单一连接，两个对象间相同的信号和槽只能有唯一的关联，防止重复关联。
			属性系统：
				Q_PROPERTY(type name 			//type表示属性的类型
				(READ getFunction 				//READ表示读操作焊丝。如果MEMBER变量没有指定，那么该函数是必须有的。
				[WRITE setFunction]| 			//一个可选的写操作函数。它用来设置属性的值。
				MEMBER meMberName [READ getFunction| WRITE setFunction])//如果没有指定READ操作焊丝，那么必须指定一个MEMBER变量关联，这样会是给定的成员变量变为可读/写的而不用创建READ和WRITE操作函数。
				[ RESET resetFunction]			//一个可选的重置函数。他用来讲属性恢复到一个默认的值。这个函数不能有参数，而且返回值必须为空void。
				[ NOTIFY notifySignal]			//一个可选的通知信号。如果使用该选项，那么需要制定类中一个已经存在的信号
				[ REVISION int]					//一个可选的版本号
				[ DESIGNABLE bool ]				//表明这个属性在Qt Designer的属性编辑器中是否可见。默认为true
				[ SCRIPTABLE bool]				//是否被脚本引擎访问，默认为true
				[STORED bool]					//对象的状态被存储时也必须存储这个属性的只，大部分属性的该值为true
				[USER bool]						//可选的USER表明这个属性是否被设计为该类的面向用户或者用户可编辑的属性。一般一个雷只有一个USER属性，它的默认值为false。
				[CONSTANT]						//这个属性是一个常量，对于给定的一个对象实例，每一次使用常量属性的READ方法都必须返回相同的值
				[FINAL])			
		}
	}
	
	{容器类
		QVector
		QMap
		QStack//先进后出
		QDeque//先进先出
		{QString
			QString str = "hello";
			str[0] = QChar('H'); //Hello
			str.append("Qt");	//Hello Qt
			str.replace(1,4,"i"); //将ello替换为i，Hi Qt
			str.trimmed();	//除去字符串两端的空白字符
			str.simplified();	//除去字符串两端和中间多余的空白字符
			str.remove(QRegExp("\\s"));//去掉字符里面的所有字符
			
			//将','替换成空格，并且去掉多余的','
			QString str ="hi,my,,qt";
			QStringList list = str.split(",",QString::SkipEmptyParts);
			str = list.join(" ");
			qDebug() << "str: " << str;
			
			//查询操作
			str = "yafeilinux";
			str.right(5); //linux
			str.left(5);//yafei
			str.mid(2,3);//第二个位置开始，长度为3，输出fei
			
			str.at(0); //y
			str.count('i'); //2
			str.startsWith("ya");//true
			str.endsWith(linux);//true
			str.contains("lin");//true
			//转换操作
			QString.toInt();//转换为int
			QString::number(num);//数字转换为QString
			QString.toInt(bool, 16); //转换为16进制数字
			QString::number(num, 16);//数字转换为16进制的QString
			QString.toFloat();//转换为float类型
			QString.toUpper();//转为大写
			QString.toLower();//转换为小写
			QString(%1,).arg(str);//跟sprintf一样
		}
		
		QByteArray类提供了一个字节数组，它可以用来存储原始字节(包括'\0')和传统的以'\0'结尾的8位字符串。比const char*方便很多，它总是保证数据以一个'\0'结尾
			QString是存储16位的Unicode字符。
		QVariant是Qt类型的一个共用体，可以转换为任意类型。
		
		{文本捕获
			QRegExp rx(R"((\d+))");

			QString strSource = "yashagei 12 14 99 231 7 . 21 dfd 41 35473287/*5644";

			QStringList list;

			int pos = 0;
			while((pos = rx.indexIn(strSource, pos))!= -1)
			{	
				list << rx.cap(1);
				pos += rx.matchedLength();
			}
			qDebug() << list;	//("12", "14", "99", "231", "7", "21", "41", "35473287", "5644")
		}
		QRegularExpression	//正则表达式
	}
	
	
	{界面外观
		{qt样式表
			{样式规则
				选择器指定相同的声明，使用逗号隔开
					QPushButton,QLineEdit,QCombox{color:red}
				
				样式规则的声明部分是一些“属性：值”对组成的列表，它们包含在大括号中，使用分号隔开。
					QPushButton{color:red; background-color:white}
			}
			{选择器类型
				通用选择器		*							匹配所有部件
				类型选择器		QPushButton					匹配所有QPushButton实例和它的所有子类
				属性选择器		QPushButton[flat="false"]	匹配QPushButton的属性flat为false的实例
				类选择器		.QPushButton				匹配所有QPushButton实例，但不包含它的子类
				ID选择器		QPushButton#okButton		匹配所有QPushButton中以okButton为对象名的实例
				后代迭代器		QDialog QPushButton			匹配所有QPushButton实例，它们必须是QDialog的子孙部件
				孩子选择器		QDialog>QPushButton			匹配所有QPushButton实例，它们必须是QDialog的直接子部件
			}
			{伪状态(Pseudo-States) List of Pseudo-States
				伪状态出现在选择器之后，用冒号隔离
					QPushButton:hover{color:white}
				伪状态可以使用感叹号来表示否定
					QPushButton:!hover{color:red}
				伪状态还可以多个连用，达到逻辑与效果。例如，当鼠标悬停在一个被选中的QCheckBox部件上时才应用规则，
					QCheckBox:hover:checked{color:white}
				伪状态也可以和子控件联合使用
					QComboBox::drop-down:hover{image:url(dropdown_bright.png)}
			}
			{继承
				当使用Qt样式表时，部件并不会自动从父部件继承字体和颜色设置。例如，一个QPushButton包含一个QGroupBox中，这里对QGroupBox设置样式表：
					qApp->setStyleSheet("QGroupBox {color:red;}");
				但没有对QPushButton设置样式表。这时QPushButton会使用系统颜色，而不会继承QGroupBox的颜色。如果想要QGroupBox的颜色设置到其子部件上，可以这样设置样式表：
					qApp->setStyleSheet("QGroupBox,QGroupBox * {color:red;}");
				
			}
			{盒子模型(The Box Model)
				每一个部件都被看作拥有4个同心矩形的盒子，这4个矩形分别是内容(content).填衬(padding)，边框(border)和边距(margin)，它们的默认值都是0.
				可以使用backgr-image属性来为部件指定一个背景。默认的background-image只在边框以内的区域进行绘制，这个可以使用background-clip属性来更改。还可以使用background-repeat和background-origin来控制背景图片的重复方式以及原点。
				一个background-image无法随着部件的大小自动缩放，如果想要背景随着部件的大小变化，那就必须使用border-image。如果同时指定了background-image和border-image，那么border-image会绘制在background-image上。
				此外，image属性可以用来在border-image上绘制一个图片。如果使用image指定的图片大小与部件的大小不匹配，那么它不会平铺或者拉伸。图片的对齐方式可以使用image-position属性来设置。
			}
			{设置透明度
				setWindowOpacity()//0.0~1.0
				如果想窗体背景透明，而其中的部件不受影响。setAttribute(Qt::WA_TranslucentBackground);
					如果是windows下面需要setWindowFlags(Qt::FramelessWindowHint);
				上面的方法是背景完全透明，实现半透明，可以使用重绘事件。
					void Widget::paintEvent(QPaintEvent *)
					{
						QPainter painter(this);
						painter.fillRect(rect(),QColor(255, 255,255 100));
					}
					先试用rect()函数获取窗口的内部矩形，它不包含任何边框。然后使用半透明的白色对这个矩形进行填充，可以运行程序查看运行效果。fillRect()函数可以指定任意的一个区域
			}
			{设置阴影
				//创建阴影效果
				QGraphicsDropShadowEffect *effect = new QGraphicsDropShadowEf fect ;
				//设置阴影颜色
				effect ->setColor(QColor(100, 100. 100，100));
				//设置阴影模糊半径
				effect ->setBlurRadius(2);
				//设置阴影偏移值
				effect -> setOffset(10) ;
				//标签部件使用阴影效果
				ui~>label >setGraphicsEffect(effect);
			}
		}
	}
	
	{翻译
		工程文件添加对应的，.ts文件
		运行lupdate生存ts文件
		Qt Linguist打开.ts文件，完成翻译，另外发布为.qm文件
		例子：百度云：code/qt/translate
	}
	
	{动态库
		例子：百度云：code/qt/QTPluginMakeAndUse
	}
	
	{2D绘图
		Qt中提供了强大的2D绘图系统,可以使用相同的API在屏幕和绘图设备上进行绘制,主要基于QPainter、QPaintDevice和QPaintEngine这3个类。
			其中，QPainter用来执行绘图操作。QPaintDevice 提供绘图设备，是一个二维空间的抽象,可以使用Qt中提供了强大的2D绘图系统,可以使用相同的API在屏幕和绘图设备上进行
			绘制,主要基于QPainter、QPaintDevice和QPaintEngine这3个类。其中，QPainter用来执行绘图操作。
			QPaintDevice 提供绘图设备，是一个二维空间的抽象,可以使用QPainter在其上进行绘制;是所有可以进行绘制的对象的基类,它的子类主要有QWidget、QPixmap、QPicture、QImage、QPrinter和QOpenGLPaintDevice等。
			QPain-tEngine提供了一些接口,用于QPainter和QPaintDevice内部，使得QPainter 可以在不同的设备.上进行绘制;
			
			QPainter常用图形绘制函数介绍
			函数					功能
			drawArc					绘制圆弧
			drawChord				绘制弦
			drawConvexPolygon		绘制凸多边形
			drawEllipse				绘制椭圆
			drawLine				绘制线条
			drawPie					绘制扇形
			drawPoint				绘制点
			drawPolygon				绘制多边形
			drawPolyline			绘制折线
			drawRect				绘制矩形
			drawRoundedRect			绘制圆角矩形
	}
	
	{QState //qt状态机，感觉用于限定一个固定的流程
		QStateMachine machine;
		QPushButton* button =new QPushButton(this);
		button->setText("animation");
	    QState *sOne = new QState(&machine);
	    QState *sTwo = new QState(&machine);
	    QState *sThree = new QState(&machine);
	    sOne->assignProperty(button, "geometry", QRect(100,100,120,50));
	    sTwo->assignProperty(button, "geometry", QRect(300,100,120,50));
	    sThree->assignProperty(button, "geometry", QRect(200,200,120,50));
	    sOne->addTransition(button, SIGNAL(clicked()), sTwo);
	    sTwo->addTransition(button, SIGNAL(clicked()), sThree);
	    sThree->addTransition(button, SIGNAL(clicked()), sOne);
	}
	
	{音视频
		工程文件 QT += multimedia
		多媒体功能以及相关C++类
		功能												c++类
		播放音效											QSoundEffect
		播放低延迟音频										QAudioOutput
		播放编码音频(MP3,AAC等)								QMediaPlayer
		访问原始音频输入数据								QAudioInput
		录制编码音频数据									QAudioRecorder
		发现原始音频设备									QAudioDeviceInfo
		播放视频											QMediaPlayer,QAbstractVideoSurface,QVideoFrame
		收听录音机											QRadioTunder。QRadioData
		访问相机取景器										QCamera,QVideoWidget,QGraphicsVideoItem
		处理取景器											QCamera，QAbstractVideoSurface,QVideoFrame
		拍摄照片											QCamera,QCameraImageCapture
		拍摄视频											QCamera,QMediaRecorder
		
		{音频
			{QMediaPlayer 播放压缩视频,支持更过格式，占用资源少
				player = new QMediaPlayer(this);
				player->setMedia(QUrl::fromLocalFile("E:/music/Something Just Like This.mp3"));
				player->play();
			}
			{QSoundEffect 低延迟声音效果来播放未压缩的音频文件，如WAV文件(MP3播放不了)，
				effect = new QSoundEffect(this);
				effect->setSource(QUrl::fromLocalFile("E:/caocao.wav"));
				effect->setVolume(0.5);//设置音量大小 0.0~1.0
				effect->play();
				effect->setLoopCount(1);//0或者1表明只播放一次，无限循环QSoundEffect::Infinite
			}
		}
		{视频 //实际操作不行，有声音没视频画面，搞这个之前要安装K-Lite_Codec_Pack_1568_Basic，这个软件已上传百度云
		QT += multimedia multimediawidgets
			QMediaPlayer不仅可以播放音频，还可以播放视频。不过如果要视频在界面上显示出来，还需要其他类进行辅助，比如QVideoWidget,QGraphicsVideoItem或者自定义的类，
			而像GIF格式的动画类型，可以使用QMovie播放。
			添加私有对象
			QMediaPlayer *player;
			QVideoWidget *videoWidget;
		}
	}
	
	{文件，目录和输入/输出
		{文件操作
		QFile类提供了读写文件的接口，它可以读写文本文件，二进制文件和Qt资源的I/O设备。文件路径分隔符使用/符号，
			setFileName设置文件名
			exists检查文件是否存在，
			remove删除文件
			open打开			close关闭			flush刷新
		QFileInfo提供了与系统无关的文件信息，包括文件的名称，在文件系统中的位置，文件的访问权限以及是否是一个目录或者符号链接等。也可以获取文件的大小和修改/读取的时间。
			使用相对(relative)路径或者绝对(absolute)路径来指向一个文件
			文件类型isFile()、isDir()、isSymLink()来获取
			path()和fileName()来获取文件的路径和文件名，baseName()来获取文件名中的基本名称,suffix()来获取文件名的后缀，completeSuffix()获取复合后缀。
			文件的日期可以使用created()、lastModified()和lastRead()来返回
			访问权限owner()、ownerId()、group()和groupId()来获取
			permission()文件的访问权限和所有权一次性读取出来。
		}
		
		{目录QDir
			指向一个文件路径
				QDir("/home/user/Documents")
				QDir("C:/Documents and Settings")
			QDir类用来访问目录结构及其内容，可以操作路径名、访问路径和文件相关信息、操作底层的文件系统，还可以访问Qt的资源系统。
			isRelative()和isAbsolute()来判断是否为相对路径或者绝对路径
			path()获取路径，setPath()设置新的路径
			absolutePath()获取绝对路径
			dirName()获取目录名
			cd()和cdUp()改变目录路径，cdUp()跳转到父目录与cd("..")等效
			目录中包含很多条目，如文件、目录和符号链接等。一个目录中的条目数可以用count()来返回，所有条目名称列表entryList()来获取；
			每一个条目的信息，则可以使用entryInfoList()函数来获取一个QFileInfo对象的类别
			文件可以使用remove()函数来移除，rmdir()来移除目录
			可以使用名称过滤器来使用通配符指定一个模式进行文件名的匹配
				QStringList filters;
				filters << "*.cpp" << "*.cxx" << "*.cc";
				dir.setNameFilters(filters);
			可以使用setFiltter()来设置。排序顺序使用setSorting()来设置
			
			QFileSystemWatcher文件系统监视器
				提供了一个接口来监控文件和目录的修改
		}
		
		{文本流和数据流
			{QTextStream使用文本流读写文件
				提供了一个方便的接口来读/写文本，可以在QIODevice,QByteArray和QString上进行操作。对于生成文本，QTextStream对字段填充、对齐和数字格式提供了格式选项支持。			
				QFile data("output.txt");
				if(data.open(QFile::WriteOnly | QFile::Truncate))
				{
					QTextStream out(&data);
					out << "Result: " << qSetFieldWidth(10) << left << 3.14 << 2.7;
				}
			QTextStream使用了基于Unicode的缓冲区，QTextStream使用QTextCodec来自动支持不同的字符集。默认的，使用QTextCodec::codecForLocale()返回的编码来进行读/写
			QTextStream读取文本文件一般使用3种方式:
				1.readLine()或者readAll()进行一块接着一块的读取
					QFile file("in.txt");
					if(!file.open(QIODevice::ReadOnly | QIODevice::Text))
						return;
					QTextStream in(&file);
					while(!in.end())
					{
						QString line = in.readLine();
					}
				2.一个单词接着一个单词。QTextStream支持流入到QString、QByteArray和char*缓冲区，单词由空格分开，而且可以自动跳过前导空格。
				3.一个字符接着一个字符，使用QChar或者char类型的流
			}
			{QDataStream使用数据流读写二进制数据
				类实现了将QIODevice的二进制数据串行化。一个数据流就是一个二进制编码信息流。数据流也可以读写未编码的原始二进制数据。
					QFile file("file.dat");
					file.open(QIODevice::WriteOnly);
					QDataStream out(&file);
					out << QString("the answer is ");
					out << (qint32)42;
					out << (qint32)12;
					file.close();
					file.open(QIODevice::ReadOnly);
					QDataStream in(&file);
					QString str;
					qint32 a, b;
					in >> str >> a >> b;
					qDebug() << "str: " << str << " a: " << a << " b: " << b;
			}
			{其他相关类
				QUrl类提供了一个方便的接口来操作URLs。标准格式如下：
					protocol://hostname[:port] / path / [? query]#fragment
					protocol指定传输协议，比如http、ftp等;
					hostname指系统主机名或者IP地址主机名还可以包含连接到服务器所需要的的用户名和密码
					port指定端口号
					path指定主机上的目录或者文件地址
					
				QResource类提供了接口来直接读取资源文件。绝对路径可以使用文件系统的表示法，以一个"/"字符开始；或者使用资源表示法，以":"字符开始。
				
				QBuffer类为QByteArray提供了一个QIODevice接口，它允许使用QIODevice接口来访问QByteArray。
					调用open()函数打开一个缓冲区，然后使用write()或者putChar()对缓冲区进行写入，使用read()、readLine()、readAll()或者getChar()来读取它。size()返回缓冲区的当前大小，seek()定位到缓冲区位置，结束close()。
					QByteArray byteArray;
					QBuffer buffer(&byteArray);
					buffer.open(QIODevice::WriteOnly);
					QDataStream out(&buffer);
					
					QBuffer buffer(&byteArray);
					buffer.open(QIODevice::ReadOnly);
					QDataStream in(&buffer);
			}
		}
	}
	
	{模型/视图
		{模型/视图架构
			MVC(Model-View-Controller)是一种起源于Smalltalk的设计模式，
				模型(Model)是应用对象，用来表示数据;
				视图(View)是模型的用户界面，用来显示数据;
				控制(Controller),定义了用户界面对用户输入的反应方式。
			{模型
				所有的模型都基于QAbstractItemModel类，这个类定义了一个接口，可以供视图和委托来访问数据。数据本身并不一定要存储在模型中，也可以存储在一个数据结构、一个独立的类、文件、数据库或者应用程序的其他一些组件中。
				QAbstractItemModel为数据提供了一个十分灵活的接口来处理各种视图，这些视图可以将数据表现为表格(table)、列表(list)和树(tree)等形式。
				基于列表或者表格的数据结构，那么可以使用QAbstractListModel和QAbstractTableModel类
				
				Qt提供了一些线程的模型来处理数据项：
					QStringListModel用来存储一个简单的QString项目列表
					QStandardItemModel管理复杂的树型结构数据项，每一个数据项可以包含任意的数据；
					QFileSystemModel提供了本地文件系统中文件和目录的信息；
					QSqlQueryModel、QSqlTableModel和QSqlRelationTableModel用来访问数据库。
				如果QtT提供的这些标准模型无法满足需要，还可以子类化QAbstractItemModel、QAbstractListModel或者QAbstractTableModel来创建自定义的模型。
			}
			{视图
				QListView将数据项显示为一个列表，QTableView将模型中的数据显示在一个表格中，QTreeView将模型的数据项显示在具有层次的列表中。
				这些类都是基于QAbstracItemView抽象基类，这些类可以直接使用，也可以被子类化来提供定制的视图。				
			}
			{委托
				在模型/视图框架中，QAbstractItemDelegate是委托的抽象基类,默认的委托实现由QStyledItemDelegate类提供，这也被用作Qt标准视图的默认委托。
				QStyledItemDelegate使用当前的样式类绘制项目。要实现自定义的委托或者要和Qt样式表一起应用是，建议使用QStyledItemDelegate。
			}			
		}
		{模型类
			{模型索引
				为了确保数据的表示与数据的获取相分离，Qt引入了模型索引的概念。
				模型索引由QModelIndex类提供，它是对一块数据的临时引用，可以用来检索或者修改模型中的数据。
				如果需要对一块数据进行长时间的引用，则必须使用QPersistentModelIndex创建模型所以。
				如果要获得一个数据项的模型索引，则必须制动模型的3个属性：行号、列号和父项的模型索引，例如：
					QModelIndex index = model->index(row,column,parent);
				其中，row，column和parent分别代表了这3个属性。
			}
			{行和列
				在最基本的形式中，一个模型可以通过把它看做一个简单的表格来访问，这时每个数据项可以使用行号和列号来定位。
				行号和列号都是从0开始的，列表模型和表格模型的所有数据项都是根项(Root item)为父项的，这些数据项都是可以被称为顶层数据项；
				在获取这些数据项的索引时，父项的模型索引可以用QModelIndex()表示。如下代码获取：
				QModelIndex indexA = model->index(0,0,QModelIndex());
				QModelIndex indexB = model->index(1,1,QModelIndex());
				QModelIndex indexC = model->index(2,1,QModelIndex());
				
				root item				root item(c:column)				root item
				  |——	row = 0			  |_________					  |——A row=0
				  |——	row = 1			  |A________|	row = 0			  |	 |—— row=0
				  |——	row = 2			  |____B____|	row = 1			  |  |——B row=1
										  |____C____|	row = 2			  |
										  c=0  c=1						  |—— row=1
																		  |
																		  |——C row=2
				列表模型				表格模型						数模型				  
																		  
			}
			{父项
				像数视图一样的结构需要模型提供一个更加灵活的接口，因为每一个数据项都可能成为其他数据项表格的父项，一个树视图中的顶层数据项也可能包含其他的数据项列表。如果一个数据项不是顶层数据项，那么就要指定它的父项索引。
				QModelIndex indexA = model->index(0,0,QModelIndex());
				QModelIndex indexC = model->index(2,0,QModelIndex());
				QModelIndex indexB = model->index(1,0,indexA);				
			}
			{项角色
				模型中的数据项可以作为各种角色在其他组件中使用，允许为不同的情况提供不同类型的数据。例如，Qt::DisplayRole用于访问一个字符串，所以可以作为文本显示在视图中。数据项包含了一些不同角色的数据，
				这些标准的角色由枚举类型Qt::ItemDataRole来定义
							常用的角色类型
				常量					描述
				Qt::DisplayRole			数据被渲染为文本(数据为QString类型)
				Qt::DecorationRole		数据被渲染为图标等装饰(数据为QColor，QIcon或者QPixmap类型)
				Qt::EditRole			数据可以在编辑器中进行编辑(数据为QString类型)
				Qt::ToolTipRole			数据显示在数据项的工具提示中(数据为QString类型)
				Qt::StatusTipRole		数据显示在状态栏中(数据为QString类型)
				Qt::WhatsThisRole		数据显示在数据项的"What's This?"模式下(数据为QString类型)
				Qt::SizeHintRole		数据项的大小提示，将会应用到视图(数据为QSize类型)
			}
		}
		{视图类
			{基本概念
			在模型/视图架构中，视图包含了模型中的数据项，并将它们呈现给用户，而数据的表示方法可能与底层用于存储数据的数据结构完全不同。
			QAbstractItemModel提供的一个标准模型接口，还有QAbstractItemView提供的一个标准视图接口，以及使用了模型索引提供了一种通用的方法来表示数据。
			除了呈现数据，视图还处理项目间的导航，以及项目选择的某些方面，视图中的选择行为(QAbstractItemView::SelectionBehavior)和选择模式(QAbstractITemView::SelectionMode)。
				视图中的选择行为(QAbstractItemView::SelectionBehavior)
					常量										描述
					QAbstractItemView::SelectItems				选择单个项目
					QAbstractItemView::SelectRows				只选择行
					QAbstractItemView::SelectColumns			只选择列
				选择模式(QAbstractITemView::SelectionMode)
					常量										描述
					QAbstractItemView::SingleSelection			当用户选择一个项目时，所有已经选择的项目将成为未选择状态，而且用户无法在已经选择的项目上单击来取消选择。
					QAbstractItemView::ContiguousSelection		如果用户在点击一个项目时的按着Shift键，则所有当前项目和单击项目之间的项目都将被选择或者取消选择，这依赖于被单击项目的状态。
					QAbstractItemView::ExtendedSelection		具有ContiguousSelection的特性，而且还可以按着Ctrl键进行不连续的选择
					QAbstractItemView::MultiSelection			用户选择一个项目时不影响其他已经选择的项目
					QAbstractItemView::NoSelection				项目无法被选择
			对于一些视图，如QTableView和QTreeView，在显示项目的同时还可以显示标头。这是通过QHeaderView类实现的，它们使用QAbstractItemModel::headerData()函数从模型中获取数据。
			}
			{处理项目选择
				模型/视图架构中项目的选择提供了非常方便的处理方法。在视图中被选择的项目的信息存储在一个QItemSelectionModel实例中，这样被选择项目的模型索引便保持在一个独立的模型中，与所有的视图都是独立的。
					在一个模型上设置多个视图时，就可以实现在多个视图之间共享选择。
				视图中，总是有一个当前项目和一个被选择的项目，两者都是两个独立的状态。在同一时间，一个项目可以既是当前项目，同时也是被选择的项目。视图负责确保总是有一个项目作为当前项目来实现键盘导航。
					当前项目和被选择的项目的区别
								当前项目									被选择的项目
						只能有一个当前项目								可以有多个被选择的项目
						使用键盘导航键或者鼠标按键可以改变当前项目		项目是否处于被选择状态取决于几个预先定义好的模式，例如，单项选择，多重选择等
						按下F2键或者双击鼠标都可以编辑当前项目			当前项目可以通过指定一个范围来一起被使用
						当前项目会显示焦点矩形							被选择的项目会使用选择矩形来表示
				
			}
		}
		{项目视图的便捷类 //列子，百度云model
			单层的项目列表医用使用一个QListWidget和一些QListWidgetItem来显示
			
			树或者项目的层次列表由QTreeWidget和QTreeWidgetItem类提供，树部件中的每一个项目都可以有它自己的子项目
			
			项目表格使用QTableWidget和QTableWidgetItem来构建，它提供了一个包含标头和项目的可以滚动表格部件。
			
			QListWidget、QTableWidget和QTreeWidget中每一种类型的项目的都默认配置了一组不同的标志。例如每一个QListWidgetItem和QTreeWidgetItem被初始化为可用的，可以检查的，可选择的，也可以用作拖放操作的源;
				而每一个QTableWidgetItem可以被编辑和作用拖放操作的目标。尽管所有的标准项目都有一个或者两个标志来设置拖放，
				.启动项目拖拽，要将视图的dragEnable属性设置为true;
				.要允许用户将内部或者外包的项目放入视图中，需要设置视图的viewport()的acceptDrops属性为true；
				.要显示现在用户拖拽的项目将要被放置的位置，需要设置showDropIndicator属性。
		}
		{其他内容
			代理模型可以将一个模型中的数据进行排序或者过滤，然后提供给视图进行显示。Qt中提供了QSortFilterProxyModel作为标准的代理模型来外城模型中数据的排序和过滤，
				如果要使用一个代理模型，只需要为其设置源模型，然后在视图中使用该代理模型即可。
			对于QSortFilterProxyModel的使用，则可以参考Basic Sort/Filter Model Example和Address Book Example示例程序；
			如果想自定义代理模型，则可以参考Custom Sort/Filter Model Example示例程序.
		}
	}
	
	{数据库和XML
	
	}
	