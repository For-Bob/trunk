
参考 https://blog.csdn.net/qq_34760445/article/details/82931002

类的设计原则有七个，包括：开闭原则、里氏代换原则、迪米特原则（最少知道原则）、单一职责原则、接口分隔原则、依赖倒置原则、组合/聚合复用原则(这个感觉就是迪米特法则的扩展，所以下面没有详细注解)。


设计目标：开闭原则、里氏代换原则、迪米特原则
设计方法：单一职责原则、接口分隔原则、依赖倒置原则、组合/聚合复用原则

{参考https://www.cnblogs.com/alunchen/p/7060531.html
开闭原则（The Open-Closed Principle ，OCP）
	开闭原则是指在进行面向对象设计中，设计类或其他程序单位时，应该遵循：

	对扩展开放（open）
	对修改关闭（closed） 的设计原则。

系统设计需要遵循开闭原则的原因
	稳定性。开闭原则要求扩展功能不修改原来的代码，这可以让软件系统在变化中保持稳定。
	扩展性。开闭原则要求对扩展开放，通过扩展提供新的或改变原有的功能，让软件系统具有灵活的可扩展性。
	遵循开闭原则的系统设计，可以让软件系统可复用，并且易于维护。
	
开闭原则的实现方法
	为了满足开闭原则的对修改关闭原则以及扩展开放原则，应该对软件系统中的不变的部分加以抽象，在面向对象的设计中，
		可以把这些不变的部分加以抽象成不变的接口，这些不变的接口可以应对未来的扩展；
		接口的最小功能设计原则。根据这个原则，原有的接口要么可以应对未来的扩展；不足的部分可以通过定义新的接口来实现；
		模块之间的调用通过抽象接口进行，这样即使实现层发生变化，也无需修改调用方的代码。
	
	接口可以被复用，但接口的实现却不一定能被复用。
	接口是稳定的，关闭的，但接口的实现是可变的，开放的。
	可以通过对接口的不同实现以及类的继承行为等为系统增加新的或改变系统原来的功能，实现软件系统的柔性扩展。

好处：提高系统的可复用性和可维护性。

简单地说，软件系统是否有良好的接口（抽象）设计是判断软件系统是否满足开闭原则的一种重要的判断基准。现在多把开闭原则等同于面向接口的软件设计。
}

{里氏替换原则（Liskov Substitution Principle ，LSP）
	如果一个派生类的对象可能会在基类出现的地方出现运行错误，则该派生类不应该从该基类继承，或者说，应该重新设计它们之间的关系。
	里氏替换原则的作用
	
	里氏替换原则的主要作用如下。
		里氏替换原则是实现开闭原则的重要方式之一。
		它克服了继承中重写父类造成的可复用性变差的缺点。
		它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。
		
	概念理解
		也就是说，只有满足以下2个条件的OO设计才可被认为是满足了LSP原则：

		不应该在代码中出现if/else之类对派生类类型进行判断的条件。

		派生类应当可以替换基类并出现在基类能够出现的任何地方，或者说如果我们把代码中使用基类的地方用它的派生类所代替，代码还能正常工作。

	里氏替换原则(LSP)是使代码符合开闭原则的一个重要保证。

	同时LSP体现了：

		类的继承原则：如果一个派生类的对象可能会在基类出现的地方出现运行错误，则该派生类不应该从该基类继承，或者说，应该重新设计它们之间的关系。

		动作正确性保证：从另一个侧面上保证了符合LSP设计原则的类的扩展不会给已有的系统引入新的错误。

	里式替换原则的引申意义：子类可以扩展父类的功能，但不能改变父类原有的功能。

	具体来说：

		子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。
		子类中可以增加自己特有的方法。
		当子类的方法重载父类的方法时，方法的前置条件（即方法的输入/入参）要比父类方法的输入参数更宽松。
		当子类的方法实现父类的方法时（重载/重写或实现抽象方法）的后置条件（即方法的输出/返回值）要比父类更严格或相等。
}
		
{迪米特原则（最少知道原则）（Law of Demeter ，LoD）
	概念理解
		迪米特原则对类的低耦合提出了明确的要求：

	通俗的讲：一个类对自己需要耦合或调用的类知道的最少，你(被耦合或调用的类)的内部是如何复杂和我没有关系，我就知道你提供的public方法，我只调用这些方法，其它的我不关心。
	
	对于面向OOD来说，又被解释为下面两种方式：

	1）一个软件实体应当尽可能少地与其他实体发生相互作用。

	2）每一个软件单位对其他的单位都只有最少的知识，而且局限于那些与本单位密切相关的软件单位。
	例子说明：
		朋友类间也是要有距离
			我们在安装软件时，经常会有一个安装向导的过程。比如第一步确认是否安装，第二步确认License，第三步选择安装目录…..。
			
		导向类：
			public class Wizard{
			   private Random rand = new Random(System.currentTimeMillis());
			   //第一步
			   public int first(){
				   System.out.println("执行第一个方法.....");
				   return rand.nextInt(100);
			   }
			   //第二步
			   public int second(){
				   System.out.println("执行第二个方法.....");
				   return rand.nextInt(100);
			   }
			   //第三步
			   public int third(){
				   System.out.println("执行第三个方法.....");
				   return rand.nextInt(100);
			   }
			}

			InstallSoftware类：

				public class InstallSoftware{
				  public void installWizard(Wizard wizard){
					 int first = wizard.first();
					 //根据first返回的结果，看是否要执行下一步
					 if(first >50){
						 int second = wizard.second();
						 if(second >50){
							 wizard.third();
						 }
					 } 
				  }
				}

			场景类：

			public class Client{
			   public static void main(Strings[] args){
				  InstallSoftware invoker = new InstallSoftware();
				  invoker.installWizard(new Wizard());
			   }
			}
	以上的程序非常简单，但是隐藏了一个问题。Wizard类把太多的方法暴露给InstallSoftware类，导致两者的关系太亲密，耦合关系变量异常牢固。我们把Wizard类进行重构，
		修改后的Wizard类：

			public class Wizard{
			   private Random rand = new Random(System.currentTimeMillis());
			   //第一步
			   private int first(){
				   System.out.println("执行第一个方法.....");
				   return rand.nextInt(100);
			   }
			   //第二步
			   private int second(){
				   System.out.println("执行第二个方法.....");
				   return rand.nextInt(100);
			   }
			   //第三步
			   private int third(){
				   System.out.println("执行第三个方法.....");
				   return rand.nextInt(100);
			   }
			   //软件安装过程
			   public void installWizard(){
				  int first = wizard.first();
				  //根据first返回的结果，看是否要执行下一步
				  if(first >50){
					  int second = wizard.second();
					  if(second >50){
						 wizard.third();
					  }
				  } 
			  }
			}

		修改后的InstallSoftware类：

			public class InstallSoftware{
			  public void installWizard(Wizard wizard){
				 wizard.installWizard()
			  }
			}
	通过重构，类间的耦合关系变弱了，结构变得清晰，变量的风险也变小了。 
	一个类公开的public方法和属性越多，修改时涉及的面也就越大，变更引起的风险扩散也就越大。因此，为了保持朋友类间的距离，在设计时需要反复衡量：是否还可以再减少public方法和属性，是否可以修改为private,package-private,protected等访问权限，是否可以加上final关键字。

	注意： 
	迪米特原则要求类“羞涩”一点，尽量不要对外公开太多的public方法和非静态的public变量，尽量内敛，多使用private,package-private,protected等访问权限。

	是自己的就是自己的
	在实践中经常出现这样一个方法，放在本类中也可以，放到其它类中也可以。那怎么处理呢？你可以坚持一个原则：如果一个方法放在本类中，即不增加类间关系，也对本类不产生负面影响，那就放到本类中。

	迪米特原则的实践
	迪米特原则的核心观念就是类间解耦，弱耦合，只有弱耦合后，类的复用率才可以提高。其结果就是产生了大量的中转或跳转类，导致系统复杂，为维护带来了难度。所以，我们在实践时要反复权衡，即要让结构清晰，又做到高内聚低耦合。
}

{单一职责原则

	1）概念

	按照官方说明，单一职责原则是指 应该有且只有一个一个原因引起类的变更。

	通俗一点来说，一个类应该只做一类事情；一个类应该只负责一个功能。

	单一职责原则是程序设计高内聚、低耦合的引申。

	2）浮想联偏

	作者接触单一职责原则的时候，以为很简单。单一职责嘛，一个类一个方法，不就是它的终极目标吗？

	的确，这属于‘终极目标’但是此终极目标不现实。因为，一个类一个方法的确是高内聚、低耦合。但是这显然显得代码很臃肿了，维护更加不便，在中大型的项目更加如此。如果你的项目足够简单，类足够少，也可以这么来做。

	所以，这里要强调一点的是，单一职责原则是一个类处理一类事情，也只有一类事情影响到这个类。并不是一个类处理一个方法。

	3）开始理解

	我们来举个例子。作者眼前有一支黑色笔，拿这支笔来做例子吧。

	笔有它属性、被动的行为。属性有：黑色、手感好、笔尖0.5。行为有：写字、画画、扎人。当然，这里的扎人只是个例子，千万不要来真的了 >. <

	按照一般的做法，我们都把笔的属性与行为都放在一个类来做。单一职责现在就起作用了，我们要分开成属性与行为。
}
	
{参考http://www.cnblogs.com/alunchen/p/7115675.html
接口隔离原则

	1）概念

	客户端不应该依赖它不需要的接口。一个类对另一个类的依赖应该建立在最小的接口上。

	怎么理解呢？通俗一点就是说接口尽量细分，把不需要的方法尽量写在2个不同的接口上。

	假如我有一个接口Interface1，有5个方法。其中Class1想实现第1-3个方法，Class2想实现第3-5个方法。

	那么我只有一个Interface1，如果达到上面的要求，Class1与Class2只能实现Interface1的5个方法，如下：

	image

	那么就变得很臃肿了。有什么解决办法呢？接口分离原则很好地解决了以上方法。

	我们把Interface1分离3个接口，然后Class1与Class2分别继承对应的接口，如下：

	image

	这样，很好的消除了冗余。

	2）深入了解

	接口隔离原则的含义是：建立单一接口，不要建立庞大臃肿的接口，尽量细化接口，接口中的方法尽量少。也就是说，我们要为各个类建立专用的接口，而不要试图去建立一个很庞大的接口供所有依赖它的类去调用。本文例子中，将一个庞大的接口变更为3个专用的接口所采用的就是接口隔离原则。在程序设计中，依赖几个专用的接口要比依赖一个综合的接口更灵活。接口是设计时对外部设定的“契约”，通过分散定义多个接口，可以预防外来变更的扩散，提高系统的灵活性和可维护性。

	说到这里，很多人会觉的接口隔离原则跟之前的单一职责原则很相似，其实不然。其一，单一职责原则原注重的是职责；而接口隔离原则注重对接口依赖的隔离。其二，单一职责原则主要是约束类，其次才是接口和方法，它针对的是程序中的实现和细节；而接口隔离原则主要约束接口接口，主要针对抽象，针对程序整体框架的构建。

	采用接口隔离原则对接口进行约束时，要注意以下几点：

	接口尽量小，但是要有限度。对接口进行细化可以提高程序设计灵活性是不挣的事实，但是如果过小，则会造成接口数量过多，使设计复杂化。所以一定要适度。
	为依赖接口的类定制服务，只暴露给调用的类它需要的方法，它不需要的方法则隐藏起来。只有专注地为一个模块提供定制服务，才能建立最小的依赖关系。
	提高内聚，减少对外交互。使接口用最少的方法去完成最多的事情。
	运用接口隔离原则，一定要适度，接口设计的过大或过小都不好。设计接口的时候，只有多花些时间去思考和筹划，才能准确地实践这一原则。

	3）生活中例子

	比如，我们身边的手机，有打电话、支付、摄影、聊天、玩游戏功能。

	我们可以定义一个接口IPhoneOperation来说明这些功能。这样臃不臃肿，要看业务逻辑。

	我们现在定一个业务逻辑，把手机功能分成业余娱乐、生活支付、工作电话。可以拆分接口分别为：

	image

	拆分各种接口后，在业务层面我们更加容易地了解各自的业务功能实现；在代码层面我们更加的高内聚，低耦合。	
}	
	单一职责原则和接口分隔原则的区别
		单一职责强调的是接口、类、方法的职责是单一的，强调职责，方法可以多，针对程序中实现的细节；

		接口分隔原则主要是约束接口，针对抽象、整体框架。
		
{依赖倒置原则(Dependence Inversion Principle, DIP) 参考：https://blog.csdn.net/king123456man/article/details/81626127		
	
	1）概念

		高层模块不应该依赖低层模块，两者都应该依赖其抽象
		抽象不应该依赖细节
		细节应该依赖抽象

		class Driver {
		  //司机的主要职责就是驾驶汽车
		   void drive(Benz benz){
			  benz.run();
		  }
		}

		class Benz {
			//汽车肯定会跑
			void run(){
				cout << ("奔驰汽车开始运行...") << endl;
			}
		}

	//高层模块
	   void main(char* argv[], int argc) {
		 Driver xiaoLi = new Driver();
		 Benz benz = new Benz();
		//小李开奔驰车
		xiaoLi.drive(benz);
	}

	 这样的设计乍一看好像也没有问题，小李只管开着他的奔驰车就好。但是假如有一天他不想开奔驰了，想换一辆宝马车玩玩怎么办呢？我们当然可以新建一个宝马车类，也给它弄一个run()方法，但问题是，这辆车有是有了，但是小李却不能开啊。因为司机类里面并没有宝马车的依赖，所以小李空看着宝马车在那儿躺着，自己却没有钥匙，你说郁不郁闷呢？

	class BMW {
		//宝马车当然也可以开动了
	   void run(){
		cout << ("宝马汽车开始运行...") << endl;
		}
	}

	 上面的设计没有使用依赖倒置原则，我们已经郁闷的发现，模块与模块之间耦合度太高，生产力太低，只要需求一变就需要大面积重构，说明这样的设计是不合理。现在我们引入依赖倒置原则

	//将司机模块抽象为一个接口
	class IDriver {
		 //是司机就应该会驾驶汽车
		 void drive(ICar car);
	}

	class Driver public: IDriver{
		//司机的主要职责就是驾驶汽车
		void drive(ICar car){
			car.run();
		}
	}

	//将汽车模块抽象为一个接口：可以是奔驰汽车，也可以是宝马汽车
	public ICar {
		  //是汽车就应该能跑
		  void run();
	}

	class Benz public: ICar{
		//汽车肯定会跑
		void run(){
			cout << ("奔驰汽车开始运行...") << endl;
		}
	}

	class BMW public: ICar{
	   //宝马车当然也可以开动了
	   void run(){
		  cout << ("宝马汽车开始运行...") << endl;
	   }
	}

	//高层模块
	 void main() {
	   IDriver xiaoLi = new Driver();
	   ICar benz = new Benz();
	  //小李开奔驰车
	  xiaoLi.drive(benz);
   }
   在新增低层模块时，只修改了高层模块(业务场景类)，对其他低层模块(Driver类)不需要做任何修改，可以把"变更"的风险降低到最低。只要定义变量就必然有类型，并且可以有两种类型：表面类型和实际类型，表面类型是在定义时赋予的类型，实际类型是对象的类型。就如上面的例子中，小李的表面类型是IDriver，实际类型是Driver。

   
	抽象是对实现的约束，是对依赖者的一种契约，不仅仅约束自己，还同时约束自己与外部的关系，其目的就是保证所有的细节不脱离契约的范畴，确保约束双方按照规定好的契约(抽象)共同发展，只要抽象这条线还在，细节就脱离不了这个圈圈。就好比一场篮球比赛，已经定好了规则，大家如果按照规则来打球，那么会很愉快。但是假如大家脱离了规则，那么也许比赛就无法顺利进行。

	深入理解
	 	依赖倒置原则的本质就是通过抽象(抽象类或接口)使各个类或模块实现彼此独立，不互相影响，实现模块间的松耦合。在项目中使用这个规则需要以下原则;

		每个类尽量都要有接口或抽象类，或者抽象类和接口都有： 依赖倒置原则的基本要求，有抽象才能依赖倒置
		变量的表面类型尽量是接口或者抽象类
		任何类都不应该从具体类派生
		尽量不要重写基类已经写好的方法(里式替换原则)
		结合里式替换原则来使用： 结合里式替换原则和依赖倒置原则我们可以得出一个通俗的规则，接口负责定义public属性和方法，并且声明与其他对象的依赖关系，抽象类负责公共构造部分的实现，实现类准确的实现业务逻辑，同时在适当的时候对父类进行细化。
		一句话：依赖倒置原则的核心就是面向抽象(抽象类或者接口)编程
}	
