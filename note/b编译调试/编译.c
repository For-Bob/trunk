{makefile
	
}

C到目标文件的编译过程
{
							源代码*.c
	1.预处理（预编译）		|	预处理		(展开所有的宏定义，消除“#define”;处理所有的预编译指令，比如#if、#ifdef等;处理#include预编译指令)
							预处理*.i
	2.编译					|	编译		(词法分析,即字符处理; 语法分析,)
							汇编文件(*.s)
	3.汇编					| 	汇编
							目标代码(*.obj)
	4.链接					|	链接
							可执行文件
} 

内核的分配情况
{
	1G内核空间
	3G用户空间
	{
		命令行参数->(环境变量)
		栈->(局部变量，形参，->系统分配，系统销毁)
		堆->程序员手动开辟，程序员手动释放
		静态区(data		生命周期
				bss		从定义开始到程序结束
				)		放全局变量和static修饰的变量
		只读区->字符串常量
		text->指令
	}
}

{gcc编译
	-c			编译、汇编到目标代码，不进行链接
	-o outfile	输出到指定的文件。
	-g			编译的时候加上gdb调试信息
	-Wall		会打开一些很有用的警告选项
	-w			禁止显示所有警告信息。
	-v    		启动所有报警
	-fverbose-asm：在编译成汇编语言时，把C变量的名称作为汇编语言中的注释
	-save-temps：自动输出预处理文件、汇编文件、对象文件，编译正常进行
	-fsyntax-only：只测试源文件语法是否正确，不会进行任何编译操作
	-ffreestanding：编译成独立程序，而非宿主程序
	
	-l library	进行链接时搜索名为m的库。
	-llibrary 	例子： $ gcc test.c -lm -o test
			
	-Idir 	把../inc加入到搜索头文件的路径列表中。
			例子： $ gcc test.c -I../inc -o test
	-Ldir 	把/home/foo加入到搜索库文件的路径列表中。
	例子： $ gcc -I/home/foo -L/home/foo -ltest test.c -o test
}

{ar 一般用于创建静态库
	语　　法：ar[-dmpqrtx][cfosSuvV][a<成员文件>][b<成员文件>][i<成员文件>][备存文件][成员文件]
	补充说明：ar可让您集合许多文件，成为单一的备存文件。在备存文件中，所有成员文件皆保有原来的属性与权限。

	参　　数：
	　指令参数
	　-d 　删除备存文件中的成员文件。
	　-m 　变更成员文件在备存文件中的次序。
	　-p 　显示备存文件中的成员文件内容。
	　-q 　将问家附加在备存文件末端。
	　-r 　将文件插入备存文件中。
	　-t 　显示备存文件中所包含的文件。
	　-x 　自备存文件中取出成员文件。
	　选项参数
	　a<成员文件> 　将文件插入备存文件中指定的成员文件之后。
	　b<成员文件> 　将文件插入备存文件中指定的成员文件之前。
	　c 　建立备存文件。
	　f 　为避免过长的文件名不兼容于其他系统的ar指令指令，因此可利用此参数，截掉要放入备存文件中过长的成员文件名称。
	　i<成员文件> 　将问家插入备存文件中指定的成员文件之前。
	　o 　保留备存文件中文件的日期。
	　s 　若备存文件中包含了对象模式，可利用此参数建立备存文件的符号表。
	　S 　不产生符号表。
	　u 　只将日期较新文件插入备存文件中。
	　v 　程序执行时显示详细的信息。
	　V 　显示版本信息。
	
	例如我们可以用ar rv libtest.a hello.o hello1.o来生成一个库，库名字是test，链接时可以用-ltest链接。
}