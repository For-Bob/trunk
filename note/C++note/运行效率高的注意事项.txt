参考https://www.cnblogs.com/zhangxuan/p/6531767.html

一、尽量减少值传递，多用引用来传递参数。
二、++i和i++,++i要快些，
三、循环引发的讨论(大循环放里面)
 五、局部变量VS静态变量，局部
六、避免使用多重继承
七、尽量少使用dynamic_cast
八、减少除法运算的使用
九、将小粒度函数声明为内联函数（inline）
十、多用直接初始化
十一，固定用int[],频繁插入删除用list; 不频繁插入删除，固定访问用vector
十二.整型运行速度快于浮点型，所以能用整型的地方尽量不要用浮点型计算，尤其是除法！移位运算的效率比一般的乘除法效率高！
十三、结构体定义，最好是从小的往大的定义，比如开始，char,short, int, float,doule，这样
一、尽量减少值传递，多用引用来传递参数。

二、++i和i++,++i要快些，用类做参数验证
	看了上面的第一点，你可能觉得，那不就是多调用了四个函数而已，你可能对此不屑一顾。那么来看看下面的例子，应该会让你大吃一惊。

	至于整型变量的前加和后加的区别相信大家也是很清楚的。然而在这里我想跟大家谈的却是C++类的运算符重载，为了与整形变量的用法一致，在C++中重载运算符++时一般都会把前加和后加都重载。你可能会说，你在代码中不会重载++运算符，但是你敢说你没有使用过类的++运算符重载吗？迭代器类你总使用过吧！可能到现在你还不是很懂我在说什么，那么就先看看下面的例子吧，是本人为链表写的一个内部迭代器。

1
2
3
4
5
6
7
8
9
10
11
_SingleList::Iterator& _SingleList::Iterator::operator++()//前加
{
  pNote = pNote->pNext;
  return *this;
}
_SingleList::Iterator _SingleList::Iterator::operator++(int)//后加
{
  Iterator tmp(*this);
  pNote = pNote->pNext;
  return tmp;
}
从后加的实现方式可以知道，对象利用自己创建一个临时对象（自己在函数调用的一个复制），然后改变自己的状态，并返回这个临时对象，而前加的实现方式时，直接改变自己的内部状态，并返回自己的引用。

从第一点的论述可以知道后加实现时会调用复制构造函数，在函数返回时还要调用析构函数，而由于前加实现方式直接改变对象的内部状态，并返回自己的引用，至始至终也没有创建新的对象，所以也就不会调用构造函数和析构函数。

然而更加糟糕的是，迭代器通常是用来遍历容器的，它大多应用在循环中，试想你的链表有100个元素，用下面的两种方式遍历：

for(_SingleList::Iterator it = list.begin(); it != list.end(); ++it)
{
  //do something
}
 
for(_SingleList::Iterator it = list.begin(); it != list.end(); it++)
{
  //do something
}
 
如果你的习惯不好，写了第二种形式，那么很不幸，做同样的事情，就是因为一个前加和一个后加的区别，你就要调用多200个函数，其对效率的影响可就不可忽视了。

三、循环引发的讨论
 大循环放里面
 for(int i = 0; i < 5; ++i)
 {
	for(int j = 0; j < 100; ++j);
 }
 
 五、局部变量VS静态变量
 
	局部变量的效率比使用静态变量要高
	这是因为局部变量是存在于堆栈中的，对其空间的分配仅仅是修改一次esp寄存器的内容即可（即使定义一组局部变量也是修改一次）。而局部变量存在于堆栈中最大的好处是，函数能重复使用内存，当一个函数调用完毕时，退出程序堆栈，内存空间被回收，当新的函数被调用时，局部变量又可以重新使用相同的地址。当一块数据被反复读写，其数据会留在CPU的一级缓存（Cache）中，访问速度非常快。而静态变量却不存在于堆栈中。
	
六、避免使用多重继承
	在C++中，支持多继承，即一个子类可以有多个父类。书上都会跟我们说，多重继承的复杂性和使用的困难，并告诫我们不要轻易使用多重继承。其实多重继承并不仅仅使程序和代码变得更加复杂，还会影响程序的运行效率。
	这是因为在C++中每个对象都有一个this指针指向对象本身，而C++中类对成员变量的使用是通过this的地址加偏移量来计算的，而在多重继承的情况下，这个计算会变量更加复杂，从而降低程序的运行效率。而为了解决二义性，而使用虚基类的多重继承对效率的影响更为严重，因为其继承关系更加复杂和成员变量所属的父类关系更加复杂。

七、尽量少使用dynamic_cast
	dynamic_cast的作用是进行指针或引用的类型转换，dynamic_cast的转换需要目标类型和源对象有一定的关系：继承关系。 实现从子类到基类的指针转换，实际上这种转换是非常低效的，对程序的性能影响也比较大，不可大量使用，而且继承关系越复杂，层次越深，其转换时间开销越大。在程序中应该尽量减少使用。

八、减少除法运算的使用
	无论是整数还是浮点数运算，除法都是一件运算速度很慢的指令，在计算机中实现除法是比较复杂的。所以要减少除法运算的次数，下面介绍一些简单方法来提高效率：
	1、通过数学的方法，把除法变为乘法运算，如if(a > b/c),如果a、b、c都是正数，则可写成if(a*c > b)
	2、让编译器有优化的余地，如里你要做的运算是int型的n/8的话，写成（unsigned)n/8有利于编译器的优化。而要让编译器有优化的余地，则除数必须为常数，而这也可以用const修饰一个变量来达到目的。

九、将小粒度函数声明为内联函数（inline）
	正如我们所知，调用函数是需要保护现场，为局部变量分配内存，函数结束后还要恢复现场等开销，而内联函数则是把它的代码直接写到调用函数处，所以不需要这些开销，但会使程序的源代码长度变大。

	所以若是小粒度的函数，如下面的Max函数，由于不需要调用普通函数的开销，所以可以提高程序的效率。

	int Max(int a, int b)
	{
	  return a>b?a:b;
	}

十、多用直接初始化
	与直接初始化对应的是复制初始化，什么是直接初始化？什么又是复制初始化？举个简单的例子，
	ClassTest ct1;
	ClassTest ct2(ct1);  //直接初始化
	ClassTest ct3 = ct1;  //复制初始化
	那么直接初始化与复制初始化又有什么不同呢？直接初始化是直接以一个对象来构造另一个对象，如用ct1来构造ct2，复制初始化是先构造一个对象，再把另一个对象值复制给这个对象，如先构造一个对象ct3，再把ct1中的成员变量的值复制给ct3，从这里，可以看出直接初始化的效率更高一点，而且使用直接初始化还是一个好处，就是对于不能进行复制操作的对象，如流对象，是不能使用赋值初始化的，只能进行直接初始化。可能我说得不太清楚，那么下面就引用一下经典吧！	